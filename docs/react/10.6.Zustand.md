---
date: 
  created: 2025-10-07
---

# Zustand (State Management)

---

## 1. Introduction & Core Concepts

### {++What is Zustand?++}

- Zustand is a tiny, unopinionated state-management library for React (and React Native) that exposes a simple hook-based API.
- Instead of reducers, action types, or Providers, you create a store with `create()` and consume it with a hook
- e.g. `const count = useStore(s => s.count)`.
- It's designed to be minimal, fast, and flexible so you can adopt it incrementally.

### {++Core philosophy++}

- **Minimal boilerplate:** write plain functions and objects, not lots of wiring.  
- **Local-thinking global state:** encourage small focused stores (or slices) rather than a single monolithic store.  
- **Selector-driven updates:** components subscribe to just the pieces they need, reducing re-renders.  
- **Composable middleware:** add persistence, immutability helpers, devtools, etc., through small middlewares.  
- **Works outside React too:** you can create a vanilla store for non-React code or server-side logic.

### {++Key concepts & primitives++}

- **Store** — created via `create((set, get) => ({ ... }))`. Returns a hook you use inside components.  
- **`set`** — function provided to update state. Can accept partial updates or an updater function.  
- **`get`** — read current state inside actions (useful for derived updates).  
- **Selectors** — `useStore(s => s.someValue)` subscribes only to `someValue`. Zustand re-renders the component only when that value changes.  
- **`subscribe`** — low-level subscription API for effects outside React.  
- **Middleware** — small enhancers like `persist`, `devtools`, `immer` that wrap the store factory.  
- **Slices / multiple stores** — recommended pattern for separation of concerns: user slice, ui slice, data slice, etc.  
- **Vanilla stores** — `createStore` / `zustand/vanilla` for usage outside components (e.g., plain JS modules, tests).

### {++Why use Zustand? (concise advantages)++}

- **Extremely low overhead** — tiny API surface and small bundle size.  
- **Simple mental model** — state is just an object; actions are functions that call `set`.  
- **Selective re-rendering** — avoids React Context’s coarse re-renders by letting components pick exactly what they need.  
- **Great TypeScript ergonomics** — typing stores is straightforward and ergonomic.  
- **Composable & incrementally adoptable** — you can add Zustand to only the parts of your app that need shared state.  
- **Pairs well with server-state libraries** (React Query, SWR) — use Zustand for UI state and React Query for server cache.

### {++When to choose Zustand (guidance)++}

Choose Zustand when:

- Your app needs a simple global/shared state without Redux boilerplate.  
- You want high-performance subscriptions without wiring selectors into `connect` or `useSelector`.  
- You prefer a small, flexible tool that’s easy to reason about and test.

### {++example++}

```js
// store.js
import { create } from 'zustand';

const useStore = create((set, get) => ({
  count: 0,
  increase: () => set(state => ({ count: state.count + 1 })),
  reset: () => set({ count: 0 }),
  incrementIfOdd: () => {
    if (get().count % 2 === 1) set(state => ({ count: state.count + 1 }));
  },
}));

export default useStore;
```

```ts
// store.ts
import { create } from 'zustand';

interface StoreState {
  count: number;
  increase: () => void;
  reset: () => void;
  incrementIfOdd: () => void;
}

const useStore = create<StoreState>((set, get) => ({
  count: 0,
  increase: () => set((state) => ({ count: state.count + 1 })),
  reset: () => set({ count: 0 }),
  incrementIfOdd: () => {
    if (get().count % 2 === 1) set((state) => ({ count: state.count + 1 }));
  },
}));

export default useStore;
```

---

## 2. Installation & Basic Setup

### {++Installing Zustand++}

Install Zustand using your preferred package manager:

```bash
npm install zustand
```

``` bash
# or
yarn add zustand
# or
pnpm add zustand
```

Zustand works out of the box with React, React Native, and TypeScript — no extra setup needed.

### {++Creating Your First Store++}

A Zustand store is a central place that defines:

- The **state** (data)
- The **actions** (functions that modify state)

You can create as many stores as you want — for example: `counterStore`, `userStore`, `todoStore`, etc.

Create a global store using create() that contains both state and actions.

```js
// store.js
import { create } from 'zustand';

const useCounterStore = create((set) => ({
  count: 0,
  increase: () => set((state) => ({ count: state.count + 1 })),
  decrease: () => set((state) => ({ count: state.count - 1 })),
}));

export default useCounterStore;
```

```ts
// store.ts
import { create } from 'zustand';

interface CounterState {
  count: number;
  increase: () => void;
  decrease: () => void;
}

const useCounterStore = create<CounterState>((set) => ({
  count: 0,
  increase: () => set((state) => ({ count: state.count + 1 })),
  decrease: () => set((state) => ({ count: state.count - 1 })),
}));

export default useCounterStore;
```

### {++Using the Store in Components++}

Once a store is created, you can use it directly inside any React component.  
Each component subscribes only to the part of the state it needs, preventing unnecessary re-renders.

To access state:

- Use `const count = useCounterStore((state) => state.count);`

To call actions:

- Use `const increase = useCounterStore((state) => state.increase);`

You can also:

- **Read state** without rendering → `useCounterStore.getState()`
- **Update state** without rendering → `useCounterStore.setState()`

Use the store hook directly inside React components to read or modify state.

```jsx
// Counter.jsx
import useCounterStore from './store';

export default function Counter() {
  const { count, increase, decrease } = useCounterStore();

  return (
    <div>
      <h2>Count: {count}</h2>
      <button onClick={increase}>+</button>
      <button onClick={decrease}>−</button>
    </div>
  );
}
```

```tsx
// Counter.tsx
import React from 'react';
import useCounterStore from './store';

const Counter: React.FC = () => {
  const { count, increase, decrease } = useCounterStore();

  return (
    <div>
      <h2>Count: {count}</h2>
      <button onClick={increase}>+</button>
      <button onClick={decrease}>−</button>
    </div>
  );
};

export default Counter;
```

💡 To optimize re-renders, select only specific parts of the store:

```tsx
// Counter.tsx
import React from 'react';
import useCounterStore from './store';

const Counter: React.FC = () => {
  const count = useCounterStore((s) => s.count);
  const increase = useCounterStore((s) => s.increase);
  const decrease = useCounterStore((s) => s.decrease);

  return (
    <div>
      <h2>Count: {count}</h2>
      <button onClick={increase}>+</button>
      <button onClick={decrease}>−</button>
    </div>
  );
};

export default Counter;
```

---

## 3. State & Actions

```ts
// store.ts
// store is the place where you store your state and 
// any function that updates that state.

import { create } from "zustand";

// type
type CounterStore = {
  count: number;
  increment: () => void;
  incrementAsync: () => Promise<void>;
  decrement: () => void;
  decrementAsync: () => Promise<void>;
};

// create and export the store
// create is used to create a global store (a container for your app’s state and actions).
export const useCounterStore = create<CounterStore>((set) => ({
  // the vaules
  count: 0,
  // the functions to set new value and update the state
  // set is used to update the state in your store.
  increment: () => {
    set(((state) => ({ count: state.count + 1 })));
  },
  incrementAsync: async () => {
    await new Promise((resolve) => setTimeout(resolve, 1000));
    set(((state) => ({ count: state.count + 1 })));
  },
  decrement: () => {
    set(((state) => ({ count: state.count - 1 })));
  },
  decrementAsync: async () => {
    await new Promise((resolve) => setTimeout(resolve, 1000));
    set(((state) => ({ count: state.count - 1 })));
  },
}));
```

```tsx
// App.tsx
import { useEffect } from "react";
import "./App.css";
// import the useCounterStore from store
import { useCounterStore } from "./store";

// get the value from the store directly
const logCount = () => {
  const count = useCounterStore.getState().count;
  console.log("count", count);
};

// change or set the value from the store directly
const resetCount = () => {
  useCounterStore.setState({count: 0});
};

const App = () => {
  // make a variable for the count from the store
  const count = useCounterStore((state) => state.count);
  // passing the count as a props
  return <OtherComponent count={count} />;
};

const OtherComponent = ({ count }: { count: number }) => {
  // make a variable for the increment function
  const increment = useCounterStore((state) => state.increment);
  const decrement = useCounterStore((state) => state.decrement);
  const incrementAsync = useCounterStore((state) => state.incrementAsync);
  const decrementAsync = useCounterStore((state) => state.decrementAsync);

  // direct use 1
  useEffect(() => {
    logCount();
  }, []);

  return (
    <>
      {/* using the actual value and function from the store */}
      <div className="text-2xl p-4">Count is : 
        <span className="font-bold text-blue-400">{count}</span>
      </div>
      <div className="bg-blue-200 grid grid-cols-2 gap-2 p-2 rounded-xl">
        <button onClick={increment}>Increment</button>
        <button onClick={decrement}>Decrement</button>
        <button onClick={incrementAsync}>IncrementAsync</button>
        <button onClick={decrementAsync}>DecrementAsync</button>
        {/* direct use 2 */}
        <button onClick={resetCount} className="text-red-400">Reset Count</button>
      </div>
    </>
  );
};

export default App;
```

---

## 4. Selectors & Optimization

Efficient state selection and optimization are key to Zustand’s performance.  
Unlike Context API, Zustand only re-renders components that use the part of the state that actually changes.

### 🔹 Selecting Specific State Slices

Zustand lets you “select” only the part of the state your component needs.  
This reduces unnecessary re-renders and improves performance.

Example usage:

- `const count = useCounterStore((state) => state.count);`
- `const increase = useCounterStore((state) => state.increase);`

💡 **Best Practice:** Always select specific slices of state instead of the entire store.

### 🔹 Avoiding Unnecessary Re-renders

If you destructure the entire store like this:

```tsx
const { count, increase, decrease } = useCounterStore();
```

The component will re-render whenever any property in the store changes.

✅ Instead, subscribe only to what’s needed:

```tsx
const count = useCounterStore((state) => state.count);
```

This ensures that your component only re-renders when count changes.

### 🔹 Using shallow Comparison for Optimization

When selecting multiple values, Zustand provides a shallow comparison helper to prevent re-renders when selected values haven’t actually changed.

You can import it from zustand/shallow:

```tsx
import { shallow } from 'zustand/shallow';
```

Then use it like:

```tsx
const { count, increase } = useCounterStore(
  (state) => ({ count: state.count, increase: state.increase }),
  shallow
);
```

This ensures re-renders only happen if either count or increase changes — not when other parts of the store update.

---

## 5. Middlewares

Zustand provides powerful **middlewares** that extend its functionality — such as persistence, debugging, and immutable state updates.  
You can easily combine multiple middlewares for more advanced setups.

### 🔹 `persist` — Saving State to Storage

The `persist` middleware allows your store to **automatically save and rehydrate state** from localStorage, sessionStorage, or custom storage.

**Use Case:**  
Keeping user preferences, cart data, or session info persistent between page reloads.

**Key Points:**

- Import from `zustand/middleware`
- Wrap your store definition with `persist`
- Define a unique key for storage

**Features:**

- Works with both sync and async storages
- Allows migration, versioning, and partial persistence
- Can blacklist or whitelist certain parts of the state

### 🔹 `devtools` — Debugging with Redux DevTools

The `devtools` middleware enables **time-travel debugging** and inspection via the popular **Redux DevTools** browser extension.

**Use Case:**  
Monitoring and debugging state changes easily during development.

**Key Points:**

- Import from `zustand/middleware`
- Wrap your store with `devtools`
- Add a name for your store in the DevTools tab

**Features:**

- Shows every action and its payload  
- Allows stepping through past state changes  
- Works seamlessly with other middlewares like `persist`

💡 **Tip:** Use `devtools` only in development mode to avoid performance overhead in production.

### 🔹 `immer` — Simplifying Immutable Updates

Zustand supports using **Immer** to simplify complex state mutations while keeping immutability intact.

**Use Case:**  
When your state has deeply nested objects and you want cleaner update logic.

**Key Points:**

- Import from `zustand/middleware/immer`
- Write “mutable-looking” code that produces immutable updates under the hood

**Example Concept:**
Instead of:

```ts
set((state) => ({
  user: { ...state.user, profile: { ...state.user.profile, name: "John" } }
}));
```

You can write:

```ts
set((state) => {
  state.user.profile.name = "John";
});
```

---

## 6. Key Concepts

### 🔹 `create()`

- Core function that creates a Zustand store.
- Returns a **custom hook** you can use anywhere in React.
- Example: `const useStore = create((set) => ({ count: 0 }))`

### 🔹 `set()`

- Function provided by Zustand to update the store.
- Works similar to React’s `setState()`, but at a global level.

### 🔹 Async Actions

You can define async actions directly in the store — no need for extra middleware like Redux Thunk.

---

## 7. Best Practices

- Keep the store minimal — only include truly shared or global state.  
- Group related logic into separate stores (e.g., `authStore`, `cartStore`).  
- Use **selectors** (like `(state) => state.value`) for performance.  
- Avoid destructuring the entire store to prevent re-renders.  
- Use TypeScript interfaces or types to define store structure clearly.  
- Access store outside React only when required (e.g., debugging, utility functions).
