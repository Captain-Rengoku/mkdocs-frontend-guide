---
date: 
  created: 2024-11-06
---

# React Hooks (Fundamentals & Advanced)

<!-- - **Introduction to Hooks**
  - Why Hooks Were Introduced
  - Rules of Hooks
  - Migrating from Class Components to Hooks
- **useState Hook**
  - Initializing State
  - Updating State Correctly
  - Functional Updates
  - Lazy Initialization
- **useEffect Hook**
  - Running Side Effects After Rendering
  - Cleaning Up Effects
  - Dependencies in useEffect
  - Avoiding Infinite Loops
- **useRef Hook**
  - Accessing DOM Elements
  - Persisting Values Without Re-renders
  - Storing Previous State Values
- **useMemo Hook**
  - Performance Optimization for Expensive Calculations
  - Dependency Array Best Practices
- **useCallback Hook**
  - Passing Functions to Child Components
  - Using useCallback with useEffect
  - useCallback with Dynamic Dependencies
  - Difference between useMemo and useCallback
  - When NOT to use useCallback
- **useReducer Hook**
  - Alternative to useState for Complex State
  - Understanding Actions and Reducers
  - Combining Reducers
- **useContext Hook**
  - Consuming Context Without Wrapper Components
  - Avoiding Prop Drilling
  - Best Practices for Context API
- **Custom Hooks in React**
  - When to Create Custom Hooks
  - Sharing Logic Between Components
  - Best Practices for Custom Hooks -->

---

## **1.Introduction to Hooks**

### Why Hooks Were Introduced

Before React Hooks, functional components were stateless, and all stateful logic had to be handled in class components.
Hooks allow functional components to use state and lifecycle features, leading to:

- **Better Code Reusability**: Hooks let you extract component logic into reusable functions.
- **Easier State Management**: Avoid complex class-based lifecycle methods.
- **Reduced Boilerplate**: No need to bind `this` in class components.

### Component LifeCycle Status

- Lifecycle methods manage a component’s behavior at different stages (mounting, updating, unmounting).
- Let's compare how lifecycle works in JavaScript, React class components, and functional components using Hooks.

- **Counter in Vanilla JavaScript**
      - In plain JavaScript, there's no built-in state management like React.
      - You typically manage state using variables, functions, and event listeners.
          - window.onload → Runs when the page loads
          - setInterval / setTimeout → Mimic state updates
          - window.onunload → Runs when the page closes

    ```html
    <!DOCTYPE html>
    <html>
    <head>
      <title>Lifecycle Example</title>
    </head>
    <body>
      <div id="app"></div>
    
      <script>
        function createComponent() {
          let count = 0;
          const app = document.getElementById("app");
    
          function render() {
            app.innerHTML = `<p>Count: ${count}</p><button id="btn">Increment</button>`;
            document.getElementById("btn").addEventListener("click", increment);
          }
    
          function increment() {
            count++;
            render();
          }
    
          // Simulating component mount
          window.onload = () => {
            console.log("Component Mounted");
            render();
          };
    
          // Simulating component unmount
          window.onunload = () => {
            console.log("Component Unmounted");
          };
        }
    
        createComponent();
      </script>
    </body>
    </html>
    ```

- Problems in Vanilla JS:
      - Manual DOM manipulation → Hard to maintain
      - Global event listeners → Risk of memory leaks
      - No clear lifecycle separation

- **State and Lifecycle in React Class Components**
      - React introduced state and lifecycle methods to handle dynamic data updates and component behavior over time.
      - `State in Class Components`
        - State is a built-in object that allows a component to store and manage data dynamically.
        - It is updated using `setState()`
      - `Lifecycle Methods in Class Components`
        - Lifecycle methods help execute code at specific points in a component’s lifecycle:
            - `componentDidMount()`: Runs after component mounts (good for API calls).
            - `componentDidUpdate()`: Runs when the component updates.
            - `componentWillUnmount()`: Runs before component is destroyed.

    ```jsx
    import React, { Component } from "react";
    
    class LifecycleDemo extends Component {
      constructor(props) {
        super(props);
        this.state = { count: 0 };
        console.log("Constructor: Component is initialized");
      }
    
      componentDidMount() {
        console.log("componentDidMount: Component mounted");
      }
    
      componentDidUpdate() {
        console.log("componentDidUpdate: State updated");
      }
    
      componentWillUnmount() {
        console.log("componentWillUnmount: Cleanup before unmounting");
      }
    
      increment = () => {
        this.setState((prevState) => ({ count: prevState.count + 1 }));
      };
    
      render() {
        console.log("Render: Component is rendering");
        return (
          <div>
            <p>Count: {this.state.count}</p>
            <button onClick={this.increment}>Increment</button>
          </div>
        );
      }
    }
    
    export default LifecycleDemo;
    ```

- How it happens
      - Mounting: constructor() → componentDidMount()
      - Updating: render() → componentDidUpdate()
      - Unmounting: componentWillUnmount()

- **State and Lifecycle in React Hooks (Functional Components)**
      - React Hooks replace class-based state and lifecycle methods in functional components.
      - Key Hooks for State and Lifecycle
          - `useState()`: Manages state.
          - `useEffect()`: Handles lifecycle events like `componentDidMount`, `componentDidUpdate`, and `componentWillUnmount`.

    ```jsx
    import React, { useState, useEffect } from "react";
    
    function LifecycleDemo() {
      const [count, setCount] = useState(0);
    
      useEffect(() => {
        console.log("Component Mounted");
        
        return () => {
          console.log("Component Will Unmount");
        };
      }, []); // Runs once on mount & cleanup on unmount
    
      useEffect(() => {
        console.log("Component Updated: Count changed");
      }, [count]); // Runs when `count` changes
    
      return (
        <div>
          <p>Count: {count}</p>
          <button onClick={() => setCount(count + 1)}>Increment</button>
        </div>
      );
    }
    
    export default LifecycleDemo;
    ```

### Rules of Hooks

- **Only Call Hooks at the Top Level**: Do not use hooks inside loops, conditions, or nested functions.

    ```jsx
    function Counter() {
      const [count, setCount] = useState(0); // Hook at the top level
    
      return (
        <div>
          <p>Count: {count}</p>
          <button onClick={() => setCount(count + 1)}>Increment</button>
        </div>
      );
    }
    ```

    ```jsx
    function Counter() {
      const [count, setCount] = useState(0);
    
      if (count > 5) {
        const [highCount, setHighCount] = useState(true); // ❌ Hook inside condition
      }
    
      return <button onClick={() => setCount(count + 1)}>Click</button>;
    }
    ```

- **Only Call Hooks from React Functions**: Hooks should be used inside React function components or custom hooks.

    ```jsx
    function useCounter() { // ✅ Custom Hook
      const [count, setCount] = useState(0);
      return { count, setCount };
    }
    
    function Counter() { // ✅ Hook inside a React component
      const { count, setCount } = useCounter();
    
      return (
        <div>
          <p>Count: {count}</p>
          <button onClick={() => setCount(count + 1)}>Increment</button>
        </div>
      );
    }
    ```

    ```jsx
    function notAComponent() {
      const [count, setCount] = useState(0); // ❌ Hook inside a normal function
    }
    ```

### Migrating from Class Components to Hooks

- Example of converting a class component to a functional component with hooks:

```jsx
// Class Component
class Counter extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
  }

  increment = () => {
    this.setState({ count: this.state.count + 1 });
  };

  render() {
    return (
      <div>
        <p>Count: {this.state.count}</p>
        <button onClick={this.increment}>Increment</button>
      </div>
    );
  }
}
```

```jsx
// Functional Component with Hooks
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

---

![React Hooks](../assets/reacthooks.png)

---

## **2.useState Hook**

The useState hook is used to manage state in functional components.

### Initializing State

- When using useState, you provide an initial value for the state variable.
- This value is used only during the first render.

```jsx
const [count, setCount] = useState(0);
```

### Updating State Correctly

- State updates do not merge automatically in functional components (unlike class components).
- You must ensure you update the state properly.

```jsx
setCount(count + 1); // Incorrect Way ❌
```

- Why is this bad?
      - React does not batch updates when called multiple times in a single render cycle.
      - If multiple updates rely on the previous state, they may overwrite each other.

### Functional Updates

If the new state depends on the previous state, use a function inside setState.
This ensures correct updates when state updates occur asynchronously.

```jsx
setCount(prevCount => prevCount + 1);
```

- ✅ Why is this better?
      - prevCount always holds the latest state value.
      - Ensures correct updates even if setCount is called multiple times.

```jsx
const handleClick = () => {
  setCount(prev => prev + 1);
  setCount(prev => prev + 1);
  setCount(prev => prev + 1);
};
```

### Lazy Initialization

- If the initial state requires an expensive computation, you can pass a function to useState.
- This function runs only once, during the initial render.

```jsx
const [count, setCount] = useState(() => {
  return expensiveCalculation();
});
```

```jsx
function expensiveCalculation() {
  console.log("Running expensive computation...");
  return 100; // Assume this is an expensive operation
}

function Counter() {
  const [count, setCount] = useState(() => expensiveCalculation());

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}

export default Counter;
```

---

## **3.useEffect Hook**

- The useEffect hook allows you to perform side effects in function components, such as:
      - Fetching data when a component is mounted or updated
      - Subscribing to events when a component is mounted or updated
      - Updating the DOM when a component is mounted or updated
      - Setting up timers when a component is mounted or updated

- Component Lifecycle - initialization, Mounting, Updation, Unmounting.
`useEffect(setup, dependencies)`

- **After mounting**
    Empty array as dependency []

    ```jsx
    useEffect(()=>{
      console.log("Counter Mounted");
    }, [])
    ```

- **After Unmounting**
    Empty array as dependency [] also known as cleanup function

    ```jsx
    useEffect(()=>{
      console.log("Counter Mounted");
      // when return a function it will run at the time of unmount only
      return function () {
        console.log("Unmount counter");
      }
    }, [])
    ```

- **After Updation**
    State as dependency [state]

    ```jsx
    useEffect(()=> {
      console.log("Counter Updated");
      // when return a fucntion with dependency array it will run at the time of unmount at the prevState unmount.
      return () => {
        console.log("Counter UseEffect Return")
      }
    },[count])
    ```

### Running Side Effects After Rendering

- By default, useEffect runs after every render.
- It can be used to synchronize state with external systems like:
      - Updating the document title
      - Fetching data
      - Interacting with browser APIs

```jsx
import React, { useState, useEffect } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    document.title = `Count: ${count}`;
  }, [count]); // Runs when `count` changes

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}

export default Counter;
```

- The effect updates the document title whenever count changes.
- Dependency array [count] ensures the effect runs only when count updates, not on every render.

### Cleaning Up Effects

- When using effects like timers, event listeners, or subscriptions, you should  clean them up to prevent:
      - Memory leaks (especially in long-running applications)
      - Unnecessary computations when the component unmounts or updates

- **Cleaning Up an Interval**

```jsx
import React, { useState, useEffect } from "react";

function Timer() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const interval = setInterval(() => {
      setCount((c) => c + 1);
    }, 1000);

    return () => clearInterval(interval); // Cleanup function
  }, []); // Runs only once (on mount)

  return <p>Timer: {count} seconds</p>;
}

export default Timer;
```

- setInterval runs every second.
- The cleanup function (clearInterval) ensures the timer stops when the component unmounts.

### Dependencies in useEffect

- The dependency array controls when the effect runs:
      - `No dependencies` → Runs on every render.
      - `Empty array ([])` → Runs only on mount & unmount.
      - `Specific dependencies ([var])` → Runs when those dependencies change.

Ensure dependencies are correctly specified to avoid unintended behavior.

```jsx
import React, { useState, useEffect } from "react";

function UserProfile({ userId }) {
  const [user, setUser] = useState(null);

  useEffect(() => {
    async function fetchUserData() {
      const response = await fetch(`https://jsonplaceholder.typicode.com/users/${userId}`);
      const data = await response.json();
      setUser(data);
    }

    fetchUserData();
  }, [userId]); // Runs only when `userId` changes

  return (
    <div>
      {user ? <h2>{user.name}</h2> : <p>Loading...</p>}
    </div>
  );
}

export default UserProfile;
```

---

## **4.useRef Hook**

- The useRef hook in React is a powerful tool that allows you to directly access and interact with DOM elements, as well as store values without causing re-renders.

- It does not cause a re-render atall.
- It can update the value though.

### Accessing DOM Elements

- One common use of useRef is to get direct access to a DOM element, such as an input field.

```jsx
const inputRef = useRef(null);
<input ref={inputRef} />
```

```jsx
import { useRef } from "react";

function FocusInput() {
  const inputRef = useRef(null); // Step 1: Create a reference

  const focusInput = () => {
    inputRef.current.focus(); // Step 3: Use the reference to focus the input
  };

  return (
    <div>
      <input ref={inputRef} type="text" placeholder="Type here..." /> {/* Step 2: Attach the reference */}
      <button onClick={focusInput}>Focus Input</button>
    </div>
  );
}

export default FocusInput;
// It will focus the input box when clicked on the button
```

```jsx
import { useEffect, useRef } from "react";

export default function Demo() {
  const inputRef = useRef(null); // Corrected useRef syntax

  useEffect(() => {
    inputRef.current?.focus(); // Focus the input field when the component mounts
  }, []);

  return (
    <div className="tutorial">
      <input ref={inputRef} type="text" placeholder="Type something..." />
    </div>
  );
}
// It will only focus the input box when first mounted
```

```jsx
import { useRef, useState } from "react";

export default function Demo() {
  const [count, setCount] = useState(0);
  const countRef = useRef(0);

  const handleIncrement = () => {
    setCount(count + 1);
    countRef.current++;

    console.log("State:", count); // State: 0
    // Console log will access the previous State because it is running on previous State
    // when cliked the button State will be updated but in the next render
    console.log("Ref:", countRef.current); // State: 1
    // The countRef value will be immediately change to 1 from 0
    // But we can't see because useRef does not re-renders the component.
  };

  return (
    <div className="tutorial">
      Count: {countRef.current} 
      {/*It will change because of useState rerender not because of useRef.*/}
      <button onClick={handleIncrement}>Increment</button>
    </div>
  );
}
```

```jsx
import React, { useRef, useState } from "react";

const RefCounter = () => {
  const countRef = useRef(0);
  const [state, setState] = useState(0);

  const incrementRef = () => {
    countRef.current += 1;
    console.log("Ref Count:", countRef.current);
  };

  return (
    <div>
      <h2>Ref Counter</h2>
      <p>Ref Count (no re-render): {countRef.current}</p>
      <p>State Value: {state}</p>
      <button onClick={incrementRef}>Increment Ref</button>
      <button onClick={() => setState(state + 1)}>Update State</button>
    </div>
  );
};

export default RefCounter;
```

- Clicking "Increment Ref" updates countRef.current, but the UI does not update.
- The new value only appears in the console (console.log).
- Clicking "Update State" triggers a re-render, and only then does countRef.current reflect the updated value.

### Persisting Values Without Re-renders

- The useRef hook in React allows you to persist values across renders without causing re-renders.

```jsx
const countRef = useRef(0);
countRef.current += 1;
```

- **How It Works:**
      - useRef(0) initializes a reference with a .current property set to 0.
      - On each render, countRef.current is incremented by 1.
      - Crucially, updating countRef.current does not cause a re-render of the component.
      - The value persists across renders, but changes to it won't trigger a re-render like state (useState) would.

- **When to Use useRef**
      - Storing values that don’t need to trigger re-renders (e.g., a counter that tracks renders but isn’t displayed).
      - Keeping a reference to a DOM element (ref for input, div, etc.).
      - Holding mutable values across renders (e.g., timers, intervals, previous values).

- **Tracking Renders Without Re-rendering**
      - renderCount updates every render, but its update does not cause a re-render.
      - Clicking the button updates state, which triggers a re-render, increasing renderCount.current.

```jsx
import React, { useRef, useState, useEffect } from "react";

const RenderCounter = () => {
  const renderCount = useRef(0); // Persistent value without re-renders
  const [state, setState] = useState(0);

  useEffect(() => {
    renderCount.current += 1;
  });

  return (
    <div>
      <h2>Render Counter</h2>
      <p>Component has rendered: {renderCount.current} times</p>
      <button onClick={() => setState(state + 1)}>Trigger Re-render</button>
    </div>
  );
};

export default RenderCounter;
```

- **Referencing a DOM Element (Accessing an Input Field)**
      - `div` - Scroll to a section, measure dimensions
      - `video` - Play, pause, restart a video
      - `canvas` - Draw graphics programmatically
      - `img` - Lazy loading or applying animations
      - `audio` - Control playback (play, pause, volume)
      - `form` - Reset form fields programmatically
      - `modal (div)` - Show/hide pop-ups

- **input Focus**

```jsx
import React, { useRef } from "react";

const InputFocus = () => {
  const inputRef = useRef(null); // Holds a reference to the input element

  const focusInput = () => {
    if (inputRef.current) {
      inputRef.current.focus(); // Programmatically focus input
    }
  };

  return (
    <div>
      <h2>Focus Input</h2>
      <input ref={inputRef} type="text" placeholder="Type here..." />
      <button onClick={focusInput}>Focus Input</button>
    </div>
  );
};

export default InputFocus;
```

- Clicking the "Focus Input" button programmatically moves focus to the input field.
- useRef persists the reference to the DOM element across renders without causing a re-render.

- **Manipulating a div (Scroll to Section)**

```jsx
import React, { useRef } from "react";

const ScrollToSection = () => {
  const sectionRef = useRef(null);

  const scrollToSection = () => {
    sectionRef.current?.scrollIntoView({ behavior: "smooth" });
  };

  return (
    <div style={{ height: "200vh", padding: "20px" }}>
      <button onClick={scrollToSection}>Go to Section</button>
      <div ref={sectionRef} style={{ marginTop: "150vh", padding: "20px", background: "lightblue" }}>
        <h2>Target Section</h2>
        <p>This is the section you scrolled to.</p>
      </div>
    </div>
  );
};

export default ScrollToSection;
```

- **Controlling a video Element**

```jsx
import React, { useRef } from "react";

const VideoControl = () => {
  const videoRef = useRef(null);

  const playVideo = () => videoRef.current?.play();
  const pauseVideo = () => videoRef.current?.pause();
  const restartVideo = () => {
    videoRef.current.currentTime = 0;
    videoRef.current?.play();
  };

  return (
    <div>
      <h2>Video Control</h2>
      <video ref={videoRef} width="400" controls>
        <source src="https://www.w3schools.com/html/mov_bbb.mp4" type="video/mp4" />
      </video>
      <br />
      <button onClick={playVideo}>Play</button>
      <button onClick={pauseVideo}>Pause</button>
      <button onClick={restartVideo}>Restart</button>
    </div>
  );
};

export default VideoControl;
```

- **Measuring a div's Size (Get Dimensions)**

```jsx
import React, { useRef, useState, useEffect } from "react";

const MeasureDiv = () => {
  // Reference to the div
  const divRef = useRef(null);

  // State to store width and height
  const [size, setSize] = useState({ width: 0, height: 0 });

  useEffect(() => {
    // Function to update div size
    const updateSize = () => {
      if (divRef.current) {
        setSize({
          width: divRef.current.offsetWidth,
          height: divRef.current.offsetHeight,
        });
      }
    };

    // Add event listener for window resize
    window.addEventListener("resize", updateSize);
    updateSize(); // Initial size measurement

    // Cleanup: Remove event listener when component unmounts
    return () => window.removeEventListener("resize", updateSize);
  }, []);

  return (
    <div>
      <h2>Div Size Measurement</h2>
      <div ref={divRef} style={{ width: "50%", height: "20vh", background: "lightcoral" }}>
        Resize the window to see changes
      </div>
      <p>📏 Width: {size.width}px | Height: {size.height}px</p>
    </div>
  );
};

export default MeasureDiv;
```

- **Toggling a modal (Show/Hide a Pop-up)**

```jsx
import React, { useRef } from "react";

const ModalExample = () => {
  const modalRef = useRef(null);

  const showModal = () => {
    modalRef.current.style.display = "block";
  };

  const closeModal = () => {
    modalRef.current.style.display = "none";
  };

  return (
    <div>
      <button onClick={showModal}>Open Modal</button>
      <div ref={modalRef} style={{ display: "none", position: "fixed", top: "20%", left: "50%", transform: "translate(-50%, 0)", padding: "20px", background: "white", border: "1px solid black" }}>
        <p>This is a modal</p>
        <button onClick={closeModal}>Close</button>
      </div>
    </div>
  );
};

export default ModalExample;
```

- **Holding Mutable Values Across Renders (Timers, Intervals)**

- Clicking "Start" begins an interval that updates the seconds state every second.
- Clicking "Stop" clears the interval, preventing memory leaks.
- intervalRef.current persists the interval ID without causing re-renders.

```jsx
import React, { useRef, useState } from "react";

const TimerComponent = () => {
  const intervalRef = useRef(null); // Holds the interval ID
  const [seconds, setSeconds] = useState(0);

  const startTimer = () => {
    if (!intervalRef.current) {
      intervalRef.current = setInterval(() => {
        setSeconds((prev) => prev + 1);
      }, 1000);
    }
  };

  const stopTimer = () => {
    clearInterval(intervalRef.current);
    intervalRef.current = null;
  };

  return (
    <div>
      <h2>Timer</h2>
      <p>Elapsed Time: {seconds} seconds</p>
      <button onClick={startTimer}>Start</button>
      <button onClick={stopTimer}>Stop</button>
    </div>
  );
};

export default TimerComponent;
```

---

## **5.useMemo Hook**

`Memoization` - Memoization is an optimization technique where the result of an expensive function is stored (cached) so that it doesn’t have to run again if the input values haven’t changed.

- **Fibonacci Sequence (Without Memoization) in Vanilla JS**

```js
function slowFibonacci(n) {
  if (n <= 1) return n;
  return slowFibonacci(n - 1) + slowFibonacci(n - 2); // Recursively calculates every time
}

console.log(slowFibonacci(40)); // Very slow for large numbers
```

- **Fibonacci with Memoization in Vanilla JS**

```js
function memoizedFibonacci() {
  let cache = {}; // Store previous results

  return function fib(n) {
    if (n in cache) return cache[n]; // Return from cache if already computed
    if (n <= 1) return n;

    cache[n] = fib(n - 1) + fib(n - 2);
    return cache[n];
  };
}

const fibonacci = memoizedFibonacci();
console.log(fibonacci(40)); // Much faster!
```

The `useMemo` hook helps optimize performance by caching (memoizing) the result of expensive calculations, preventing unnecessary re-computation.

- Normally, when a component re-renders, all functions inside it run again, even if their values didn’t change.
- This can slow down the app if there are complex calculations or large datasets.
- `useMemo` remembers (memoizes) the previous result and only recalculates if dependencies change.

```jsx
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
const memoizedValue = useMemo(() => calculateValue, dependencies);
```

- **Simple Example without useMemo**

  ```jsx
  import { useState } from 'react'
  
  function DoubleCounter() {
    const [count, setCount] = useState(0);
  
    function expensiveTask(num) {
      console.log("Inside Expensive Task!");
      for(let i=0; i<=2000000000; i++) {}
      return num*2;
    }
  
    let doubledValue = expensiveTask(16);
  // This will run everytime the app re-renders even when the value of 'number' doesn't change.

  
    return (
      <div>
        <div>
          Count: {count}
        </div>
        <button onClick={() => setCount(count + 1)}>
          Increment
        </button>
        <div>
          Double: {doubledValue}
        </div>
      </div>
    )
  }
  
  export default DoubleCounter
  ```

- **Simple Example with using useMemo**

  ```jsx
  import { useState, useMemo } from 'react'
    
  function DoubleCounter() {
    const [count, setCount] = useState(0);
    const [number, setNumber] = useState(0);
  
    function expensiveTask(num) {
      console.log("Inside Expensive Task!");
      for(let i=0; i<=2000000000; i++) {}
      return num*2;
    }
  
  //   let doubledValue = expensiveTask(number);
  // This will run everytime the app re-renders even when the value of 'number' doesn't change.
  
  let doubledValue = useMemo(() => expensiveTask(number), [number])
  // now expensive Task will only run when the value of 'number' is changed
  
    return (
      <div>
        <div>
          Count: {count}
        </div>
        <button onClick={() => setCount(count + 1)}>
          Increment
        </button>
        <div>
          Double: {doubledValue}
        </div>
        <input 
        type='number' 
        placeholder='enter number to double...'
        value={number}
        onChange={(e) => setNumber(e.target.value)}
        />
      </div>
    )
  }
  
  export default DoubleCounter
  ```

- **Problem: Without useMemo (Inefficient)**

  ```jsx
  import React, { useState } from "react";
  
  const ExpensiveComponent = () => {
    const [count, setCount] = useState(0);
    const [number, setNumber] = useState(5);
  
    // Expensive function that runs on every render
    const computeSquare = () => {
      console.log("Calculating...");
      return number * number;
    };
  
    return (
      <div>
        <h2>Number: {number}</h2>
        <h3>Square: {computeSquare()}</h3>
        <button onClick={() => setNumber(number + 1)}>Increase Number</button>
        <button onClick={() => setCount(count + 1)}>Increase Count</button>
        <p>Count: {count}</p>
      </div>
    );
  };
  
  export default ExpensiveComponent;
  ```

  - Every time count updates, computeSquare() re-runs, even though number didn’t change.
  - This wastes performance because we don’t need to recalculate the square unless number changes.

- **Optimized with useMemo**

  ```jsx
  import React, { useState, useMemo } from "react";
  
  const ExpensiveComponent = () => {
    const [count, setCount] = useState(0);
    const [number, setNumber] = useState(5);
  
    // Memoize the expensive calculation
    const memoizedSquare = useMemo(() => {
      console.log("Calculating...");
      return number * number;
    }, [number]); // Only recalculates if `number` changes
  
    return (
      <div>
        <h2>Number: {number}</h2>
        <h3>Square: {memoizedSquare}</h3>
        <button onClick={() => setNumber(number + 1)}>Increase Number</button>
        <button onClick={() => setCount(count + 1)}>Increase Count</button>
        <p>Count: {count}</p>
      </div>
    );
  };
  
  export default ExpensiveComponent;
  ```
  
  - useMemo(() => number * number, [number]) only recalculates when number changes.
  - If we update count, the expensive calculation is skipped.
  - Performance improves because the function does not run unnecessarily.

- **Problem: Filtering is Slow Without useMemo**

  ```jsx
  import React, { useState } from "react";
  
  const ListFilter = () => {
    const [query, setQuery] = useState("");
    const items = ["Apple", "Banana", "Grapes", "Mango", "Orange"];
  
    // Filtering runs on every render (even when not needed)
    const filteredItems = items.filter(item => {
        item.toLowerCase().includes(query.toLowerCase())
        console.log("filtered")
    });
  
    return (
      <div>
        <input type="text" value={query} onChange={e => setQuery(e.target.value)} placeholder="Search..." />
        <ul>
          {filteredItems.map(item => <li key={item}>{item}</li>)}
        </ul>
      </div>
    );
  };
  
  export default ListFilter;
  ```

  - If we filter a large list in a component, it can be slow because filtering runs on every re-render.

- **Use useMemo to Optimize Filtering**

  ```jsx
  import React, { useState, useMemo } from "react";
  
  const ListFilter = () => {
    const [query, setQuery] = useState("");
    const items = ["Apple", "Banana", "Grapes", "Mango", "Orange"];
  
    // Memoize the filtered list
    const filteredItems = useMemo(() => {
      console.log("Filtering...");
      return items.filter(item => item.toLowerCase().includes(query.toLowerCase()));
    }, [query]); // Recalculates only when `query` changes
  
    return (
      <div>
        <input type="text" value={query} onChange={e => setQuery(e.target.value)} placeholder="Search..." />
        <ul>
          {filteredItems.map(item => <li key={item}>{item}</li>)}
        </ul>
      </div>
    );
  };
  
  export default ListFilter;
  ```

  - useMemo ensures the filtering only happens when query changes.
  - If the user types in the input, filtering runs.
  - If the component re-renders for other reasons, filtering does not run again unnecessarily.

---

## **5.5 React.memo()**

- `React.memo()` is a higher-order component (HOC) in React that optimizes functional components by preventing unnecessary re-renders.
- `React.memo()` prevents a functional component from unnecessary re-renders.
- It works by memoizing the rendered output of a component and only re-rendering it when its props change.

  ```jsx
  const MemoizedComponent = React.memo(MyComponent);
  ```

  ```jsx
  const MemoizedComponent = React.memo((props) => {
    return <div>{props.value}</div>;
  });
  ```

- **When to Use React.memo()**
      - The component re-renders frequently with the same props.
      - The component is a pure function (output depends only on props).
      - The parent component updates often, causing unnecessary re-renders.

- **Basic Example**

  ```jsx
  import React, { useState } from "react";
    
  const ChildComponent = ({ count }) => {
    console.log("Child component re-rendered");
    return <p>Count: {count}</p>;
  };
  
  const OtherChildComponent = React.memo(({ otherCount }) => {
    console.log("Other Child component re-rendered");
    return <p>Other Count: {otherCount}</p>;
  });
  
  const ParentComponent = () => {
    const [count, setCount] = useState(0);
    const [otherCount, setotherCount] = useState(0);
  
    return (
      <div>
        <button onClick={() => setCount(count + 1)}>Increment Count</button>
        <button onClick={() => setotherCount(otherCount + 1)}>Increment Other Count</button>
        <ChildComponent count={count} />
        {/* This will re-render unnecessarily even when otherCount changes */}
        <OtherChildComponent otherCount={otherCount} />
        {/* This will not re-render unnecessarily even when Count changes will only re-render when it's props otherCount changes because we used React.memo()*/}
      </div>
    );
  };
  
  export default ParentComponent;
  ```

- OtherChildComponent will only re-render when otherCount changes.
- Clicking "Increment Count" does not trigger a re-render of OtherChildComponent.

---

## **6.useCallback Hook**

- The useCallback hook in React is used to memoize functions so that they are not recreated on every render.
- This helps improve performance, especially in cases where functions are passed as props to child components.
- Every time a React component re-renders, any functions defined inside it are re-created.
- In most cases, this is fine, but when passing functions as props to child components, it can lead to unnecessary re-renders of those children.
- useCallback prevents this by returning the same function instance unless its dependencies change.

```jsx
const memoizedFunction = useCallback(() => {
  // function logic here
}, [dependencies]);
```

- The first argument is the function to memoize.
- The second argument is an array of dependencies. If any dependency changes, the function is re-created.

- **Basic Usage**

  - increment is memoized and will not be re-created on every render.

  ```jsx
  import React, { useState, useCallback } from "react";
  
  const Counter = () => {
    const [count, setCount] = useState(0);
  
    const increment = useCallback(() => {
      setCount((prevCount) => prevCount + 1);
    }, []); // No dependencies, so this function remains the same across re-renders
  
    return (
      <div>
        <p>Count: {count}</p>
        <button onClick={increment}>Increment</button>
      </div>
    );
  };
  
  export default Counter;
  ```

### Passing Functions to Child Components
  
- Without useCallback, a child component would re-render every time the parent renders.
  
  ```jsx
  import React, { useState, useCallback } from "react";
  
  const Child = ({ onClick }) => {
    console.log("Child re-rendered");
    return <button onClick={onClick}>Click Me</button>;
  };
  
  const Parent = () => {
    const [count, setCount] = useState(0);
  
    const handleClick = useCallback(() => {
      console.log("Button Clicked");
    }, []); // Memoized function
  
    return (
      <div>
        <p>Count: {count}</p>
        <button onClick={() => setCount(count + 1)}>Increment Count</button>
        <Child onClick={handleClick} />
      </div>
    );
  };
  
  export default Parent;
  ```

- If handleClick was not memoized, it would be recreated on every render, causing Child to re-render unnecessarily.
- With useCallback, Child only re-renders when its props actually change.

### Using useCallback with useEffect

- Sometimes, we need a stable function reference inside useEffect.

  ```jsx
  import React, { useState, useEffect, useCallback } from "react";
  
  const Timer = () => {
    const [count, setCount] = useState(0);
  
    const tick = useCallback(() => {
      setCount((prevCount) => prevCount + 1);
    }, []); // Function stays the same across renders
  
    useEffect(() => {
      const interval = setInterval(tick, 1000);
      return () => clearInterval(interval);
    }, [tick]);
  
    return <p>Timer: {count}</p>;
  };
  
  export default Timer;
  ```

- If tick was recreated on every render, useEffect would run multiple times, leading to multiple intervals.
- Memoizing tick ensures that only one interval is set up.

### useCallback with Dynamic Dependencies

- If a function relies on state or props, we should include them as dependencies.

  ```jsx
  import React, { useState, useCallback } from "react";
  
  const App = () => {
    const [text, setText] = useState("Hello");
  
    const showAlert = useCallback(() => {
      alert(text);
    }, [text]); // Recreates function when `text` changes
  
    return (
      <div>
        <input
          type="text"
          value={text}
          onChange={(e) => setText(e.target.value)}
        />
        <button onClick={showAlert}>Show Alert</button>
      </div>
    );
  };
  
  export default App;
  ```

- If we don’t include text, the function would always use the initial value of text, ignoring updates.
- By including [text], the function updates whenever text changes.

### Difference between useMemo and useCallback

- `useMemo`: Used to memoize the result of a computation. It returns a memoized value and is used to optimize expensive calculations.
- `useCallback`: Used to memoize a function so that the function reference remains the same across renders unless its dependencies change. It returns a memoized function, not a value.

### When NOT to use useCallback

- Overuse can hurt performance: If a function is not being passed as a prop to a child component or used in useEffect, memoization might be unnecessary.
- Functions inside event handlers: If a function is used only inside the component that defines it, memoization isn’t needed.

---

## **7.useReducer Hook**

- The useReducer hook is an alternative to useState for managing complex state logic in React functional components.
- It is particularly useful when the next state depends on the previous state or when the state logic is extensive.

### Alternative to useState for Complex State

- **Basic Syntax**
The useReducer hook takes two arguments:
  - Reducer function – A function that determines how state changes based on actions.
  - Initial state – The starting value of the state.

  ```jsx
  const [state, dispatch] = useReducer(reducer, initialState);
  ```

- **Example for useReducer**

  ```jsx
  import React, { useReducer } from "react";
  
  const initialState = { count: 0 };
  
  function reducer(state, action) {
    switch (action.type) {
      case "increment":
        return { count: state.count + 1 };
      case "decrement":
        return { count: state.count - 1 };
      default:
        return state;
    }
  }
  
  const Counter = () => {
    const [state, dispatch] = useReducer(reducer, initialState);
  
    return (
      <div>
        <p>Count: {state.count}</p>
        <button onClick={() => dispatch({ type: "increment" })}>+</button>
        <button onClick={() => dispatch({ type: "decrement" })}>-</button>
      </div>
    );
  };
  
  export default Counter;
  ```

  - state holds the current count.
  - dispatch is used to send actions ({ type: "increment" }).
  - The reducer function updates state based on the action type.

### Understanding Actions and Reducers

- `Actions`: Objects that describe what should happen (e.g., { type: "increment" }).
- `Reducer Function`: A pure function that takes state and an action and returns a new state.

```jsx
function reducer(state, action) {
  switch (action.type) {
    case "increment":
      return { count: state.count + action.payload };
    case "decrement":
      return { count: state.count - action.payload };
    default:
      return state;
  }
}
```

### Combining Reducers

---

## **8. useContext Hook**

- The `useContext` hook allows you to share state or data across multiple components without passing props manually at every level.
- It's useful for accessing global data like user authentication, themes, language settings, etc.

---

### **Simplifying Prop Drilling**

- **Why useContext?**  
  Normally, if you want to pass data from a parent component to a deeply nested child, you have to pass it through all intermediate components (prop drilling). `useContext` avoids this by allowing direct access to the context.

---

### **Basic Syntax**

- The `useContext` hook takes a context object (created by `React.createContext`) and returns the current context value.

```jsx
const value = useContext(MyContext);
```

- **Example for useContext**

```jsx
import React, { createContext, useContext } from "react";

// 1. Create the context
const ThemeContext = createContext();

// 2. Create a provider component
const ThemeProvider = ({ children }) => {
  const theme = "dark"; // Could be dynamic or from state
  return (
    <ThemeContext.Provider value={theme}>
      {children}
    </ThemeContext.Provider>
  );
};

// 3. Use the context in a child component
const ThemedComponent = () => {
  const theme = useContext(ThemeContext);
  return <p>The current theme is: {theme}</p>;
};

// 4. Compose in App
const App = () => {
  return (
    <ThemeProvider>
      <ThemedComponent />
    </ThemeProvider>
  );
};

export default App;
```

---

### Understanding Context Structure

- **Context Object**: Created using `React.createContext()`. It returns an object that includes:
  - `Provider` – a component to supply the context value.
  - `Consumer` – a component to read the context value (used before hooks).

- **Provider**: A component that wraps part of the component tree and makes a value available to all its descendants via context.

- **Consumer (optional)**: Before hooks were introduced, `Consumer` was used to access context in functional components.  
  Now, `useContext()` provides a simpler and cleaner way to consume context directly.

```jsx
const MyContext = createContext(defaultValue);

// Using the provider
<MyContext.Provider value={someData}>
  <YourComponent />
</MyContext.Provider>
```

---

### When to Use useContext

- When **global state** is needed (e.g., theme, language, authentication).
- When the same data needs to be accessed by **deeply nested components**.
- When you want to avoid **prop drilling** (passing props through multiple intermediate components).

---

### Common Pattern: useContext + useReducer

- You can combine `useContext` with `useReducer` to create a **global state management pattern**.
- This pattern allows centralized state logic (via reducer) and easy access (via context) across your application—similar to how Redux works, but simpler and built-in to React.

```txt
src/
│
├── context/
│   └── CountContext.jsx
│
├── components/
│   └── Counter.jsx
│
├── App.jsx
└── main.jsx (if using Vite)
```

```jsx
// context/CountContext.jsx

import React, { createContext, useReducer, useContext } from "react";
// Create Context
const CountContext = createContext();
// Initial State
const initialState = { count: 0 };
// Reducer Function
function reducer(state, action) {
  switch (action.type) {
    case "increment":
      return { count: state.count + 1 };
    case "decrement":
      return { count: state.count - 1 };
    default:
      return state;
  }
}

// Provider Component
export const CountProvider = ({ children }) => {
  const [state, dispatch] = useReducer(reducer, initialState);
  return (
    <CountContext.Provider value={{ state, dispatch }}>
      {children}
    </CountContext.Provider>
  );
};
// Custom Hook
export const useCount = () => {
  const context = useContext(CountContext);
  if (!context) {
    throw new Error("useCount must be used within a CountProvider");
  }
  return context;
};
```

```jsx
//components/Counter.jsx
import React from "react";
import { useCount } from "../context/CountContext";

const Counter = () => {
  const { state, dispatch } = useCount();

  return (
    <div>
      <h2>Count: {state.count}</h2>
      <button onClick={() => dispatch({ type: "increment" })}>➕</button>
      <button onClick={() => dispatch({ type: "decrement" })}>➖</button>
    </div>
  );
};

export default Counter;
```

```jsx
// App.jsx
import React from "react";
import { CountProvider } from "./context/CountContext";
import Counter from "./components/Counter";

const App = () => {
  return (
    <CountProvider>
      <h1>Counter App Using useReducer + useContext</h1>
      <Counter />
    </CountProvider>
  );
};

export default App;
```

This structure:

- Promotes reusability of state logic.
- Makes it easy to test components individually.
- Adds a useCount() custom hook for cleaner usage and error handling.

---

## **9.useLayoutEffect**

---

## **10.useImperativeHandle**

---

## **11.Custom Hooks in React**

### When to Create Custom Hooks

- Create when logic needs to be shared across multiple components.

### Example of a Custom Hook

```jsx
function useLocalStorage(key, initialValue) {
  const [storedValue, setStoredValue] = useState(() => {
    return localStorage.getItem(key) || initialValue;
  });

  useEffect(() => {
    localStorage.setItem(key, storedValue);
  }, [key, storedValue]);

  return [storedValue, setStoredValue];
}
```

---

- This guide provides a comprehensive overview of React Hooks with explanations and examples. You can modify and expand as needed!

### useLocalStorage

### useFetch

---

## **12. Server Components Hooks (for SSR & Streaming)**

- `useDebugValue` – Use it inside custom hooks to show useful info in React DevTools.
- `useId` – Generates unique IDs for accessibility & form inputs. Helps with accessible form fields & avoiding ID conflicts.
- `useDeferredValue` – Defers state updates for smoother performance. Smoother UI While Typing. Defers a value update to avoid blocking the UI.
- `useTransition` – Handles UI transitions efficiently and Optimize state updates. Splits state updates into urgent and non-urgent.
- `useSyncExternalStore` – for library authors (not general app developers) to sync with external state stores. Safely subscribe to an external store (like Redux or Zustand).
- `useInsertionEffect` –  for library authors (not general app developers) to inject styles before DOM mutations happen. It’s similar to useLayoutEffect, but it runs even earlier in the React render lifecycle.
