---
date: 
  created: 2025-02-08
---

# API Calls in React
<!-- 
## 1. Fetch API vs Axios for HTTP Requests

- Introduction to Fetch API
- Using Axios for API Requests
- Pros and Cons of Fetch API vs Axios
- Setting Up Axios Interceptors

## 2. Handling Promises & Async/Await

- Using Promises with `.then()`
- Writing Asynchronous Code with `async/await`
- Error Handling in Async Functions
- Best Practices for Handling API Calls

## 3. useEffect with API Calls

- Fetching Data Inside `useEffect`
- Dependency Array and Performance Considerations
- Cleanup Functions in API Calls
- Preventing Memory Leaks with API Calls

## 4. Handling API Errors and Loading States

- Error Handling Best Practices
- Showing Loading Spinners and Skeleton UI
- Implementing Retry Logic for API Requests
- Handling Rate Limits and API Throttling

## 5. Caching API Responses with SWR and React Query

- What is SWR (Stale-While-Revalidate)?
- Fetching and Caching Data with SWR
- Introduction to React Query
- Optimistic UI Updates with React Query
- Comparison of SWR vs React Query

## 6. Working with GraphQL APIs in React (Apollo Client)

- Introduction to GraphQL
- Setting Up Apollo Client in React
- Fetching Data with `useQuery` and `useMutation`
- Using Apollo Cache for State Management
- Subscriptions with GraphQL and Apollo Client -->

---

## 1. Fetch API vs Axios for HTTP Requests

### 🔹 Introduction to Fetch API

```jsx
useEffect(() => {
  fetch('https://api.example.com/data')
    .then(response => response.json())
    .then(data => console.log(data))
    .catch(error => console.error(error));
}, []);
```

### 🔹 Using Axios for API Requests

```bash
npm install axios
```

```jsx
import axios from 'axios';

useEffect(() => {
  axios.get('https://api.example.com/data')
    .then(response => console.log(response.data))
    .catch(error => console.error(error));
}, []);
```

### 🔹 Pros and Cons of Fetch API vs Axios

| Feature             | Fetch API | Axios    |
| ------------------- | --------- | -------- |
| Default in browser  | ✅ Yes     | ❌ No     |
| Interceptors        | ❌ No      | ✅ Yes    |
| JSON auto transform | ❌ No      | ✅ Yes    |
| Error handling      | Manual    | Built-in |

### 🔹 Setting Up Axios Interceptors

```jsx
axios.interceptors.request.use(config => {
  config.headers.Authorization = `Bearer token`;
  return config;
});
```

---

## 2. Handling Promises & Async/Await

### 🔹 Using Promises with `.then()`

```jsx
fetch(url)
  .then(res => res.json())
  .then(data => console.log(data))
  .catch(err => console.error(err));
```

### 🔹 Writing Asynchronous Code with `async/await`

```jsx
const fetchData = async () => {
  try {
    const res = await fetch(url);
    const data = await res.json();
    console.log(data);
  } catch (err) {
    console.error(err);
  }
};
```

### 🔹 Error Handling in Async Functions

```jsx
try {
  // code
} catch (error) {
  console.error('API error:', error);
}
```

### 🔹 Best Practices

- Always handle errors
- Use `try/catch` inside async functions
- Keep async logic out of render

---

## 3. useEffect with API Calls

### 🔹 Fetching Data Inside `useEffect`

```jsx
useEffect(() => {
  async function loadData() {
    const res = await fetch(url);
    const data = await res.json();
    setData(data);
  }
  loadData();
}, []);
```

### 🔹 Dependency Array and Performance

- Use dependencies wisely to avoid infinite loops
- Avoid unnecessary re-renders

### 🔹 Cleanup Functions

```jsx
useEffect(() => {
  const controller = new AbortController();
  fetch(url, { signal: controller.signal });
  return () => controller.abort();
}, []);
```

### 🔹 Preventing Memory Leaks

- Use `AbortController`
- Track component mounted state with `let isMounted = true`

---

## 4. Handling API Errors and Loading States

### 🔹 Error Handling Best Practices

- Graceful fallbacks
- Display user-friendly messages

### 🔹 Showing Loading Spinners

```jsx
{loading ? <Spinner /> : <DataView data={data} />}
```

### 🔹 Retry Logic

- Use exponential backoff strategy
- Retry with a maximum count

### 🔹 Handling Rate Limits

- Respect API rate limits
- Use headers like `Retry-After`

---

## 5. Caching API Responses with SWR and React Query

### 🔹 What is SWR?

SWR = Stale While Revalidate — fetch fast, revalidate in background.

### 🔹 SWR Example

```bash
npm install swr
```

```jsx
import useSWR from 'swr';
const fetcher = url => fetch(url).then(res => res.json());

const { data, error } = useSWR('/api/data', fetcher);
```

### 🔹 React Query Example

```bash
npm install @tanstack/react-query
```

```jsx
import { useQuery } from '@tanstack/react-query';

const { data, isLoading, error } = useQuery(['todos'], fetchTodos);
```

### 🔹 Optimistic UI Updates

```jsx
mutate({ id, completed: true }, {
  optimisticData: { ...todo, completed: true },
  rollbackOnError: true
});
```

### 🔹 SWR vs React Query

| Feature            | SWR | React Query |
| ------------------ | --- | ----------- |
| Caching            | ✅   | ✅           |
| Mutation support   | ❌   | ✅           |
| Devtools           | ❌   | ✅           |
| Optimistic updates | ❌   | ✅           |

---

## 6. Working with GraphQL APIs in React (Apollo Client)

### 🔹 Introduction to GraphQL

- Declarative data fetching
- Reduces over-fetching

### 🔹 Setting Up Apollo Client

```bash
npm install @apollo/client graphql
```

```jsx
import { ApolloClient, InMemoryCache, ApolloProvider } from '@apollo/client';

const client = new ApolloClient({
  uri: 'https://example.com/graphql',
  cache: new InMemoryCache()
});

<ApolloProvider client={client}>
  <App />
</ApolloProvider>
```

### 🔹 Fetching with `useQuery`

```jsx
import { useQuery, gql } from '@apollo/client';

const GET_USERS = gql`
  query GetUsers {
    users {
      id
      name
    }
  }
`;

const { loading, error, data } = useQuery(GET_USERS);
```

### 🔹 Mutations with `useMutation`

```jsx
import { useMutation, gql } from '@apollo/client';

const ADD_USER = gql`
  mutation AddUser($name: String!) {
    addUser(name: $name) {
      id
      name
    }
  }
`;

const [addUser] = useMutation(ADD_USER);
```

### 🔹 Apollo Cache for State Management

- Automatically caches queries
- Update cache manually using `cache.writeQuery`

### 🔹 Subscriptions with Apollo Client

- Use `WebSocketLink` to enable real-time updates
- Requires Apollo Server with subscriptions
