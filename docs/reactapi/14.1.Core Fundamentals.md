---
date: 
  created: 2025-08-12
---

# Core Fundamentals

## 0. API

### What is an API?

An **API** (Application Programming Interface) is a set of rules and protocols that allows different software applications to communicate with each other.  
It defines **how** requests should be made, **what** data should be sent, and **how** responses should be structured.

Example use cases:

- A frontend web app fetching data from a backend server.
- A mobile app retrieving weather updates from a weather API.
- Payment gateways processing transactions through APIs.

### What is an API Request?

An **API request** is when a client (such as a browser, mobile app, or server) sends a request to an API to either:

- **Retrieve data** (e.g., get user profile)
- **Send data** (e.g., submit a form)
- **Update data** (e.g., edit a profile)
- **Delete data** (e.g., remove an account)

### Components of an API Request

**Endpoint (URL)**
The specific address where the API is hosted.

- <https://restful-booker.herokuapp.com/user/123>

**HTTP Method**
Defines the action to perform:

- `GET` → Retrieve data
- `POST` → Send data
- `PUT/PATCH` → Update data
- `DELETE` → Remove data

**Headers**
Extra information sent with the request, such as:

- **Authorization**: Access tokens, API keys  
    `Authorization: Bearer <token>`
- **Content-Type**: Format of the request body (e.g., JSON)  
    `Content-Type: application/json`
- **Accept**: Expected response format  
    `Accept: application/json`

**Parameters**
Extra information to customize the request.

- Types:
      - **Path Parameters** → Part of the endpoint (e.g., `/users/{id}`)
      - **Query Parameters** → Added to URL (e.g., `?page=2&limit=10`)
      - **Body Parameters** → Sent inside the request body (for `POST`, `PUT`, `PATCH`).

**Body (Payload)**
The actual data sent with `POST`, `PUT`, or `PATCH` requests.  
Example (JSON):

```json
{
  "firstname": "Kinvu",
  "lastname": "Rathor",
  "email": "kinvurathor123@example.com",
  "totalprice": 111,
  "depositpaid": true,
  "bokingdates":
  {
    "chekin":"2018-01-01",
    "checkout":"2019-01-01"
  },
  "additionalneeds":"Breakfast"
}
```

### Components of an API Response

An **API response** is the message the server sends back to the client after processing a request.

- **Status Code**

  - Indicates the result of the request.
  - Examples:

    - `200 OK`: Request successful.
    - `201 Created`: Resource successfully created.
    - `400 Bad Request`: Invalid request.
    - `401 Unauthorized`: Missing/invalid credentials.
    - `404 Not Found`: Resource doesn’t exist.
    - `500 Internal Server Error`: Server-side issue.

- **Headers**

  - Metadata about the response.
  - Examples:

    - `Content-Type`: Type of the returned content (e.g., `application/json`).
    - `Cache-Control`: How the response should be cached.

- **Body (Payload)**

  - The main content/data returned by the API.
    - Usually in JSON, XML, or other formats.
    - Example JSON:

    ```json
    {
      "id": 123,
      "name": "John Doe",
      "email": "john@example.com"
    }
    ```

- **Message**

  - Optional text explaining the result or error.
  - Often included in the response body for clarity.

### **Request Flow**

- Request flow
      - `Client sends` an `API request` (method, URL, headers, optional body).
      - `Server` processes the `request`.
      - `Server sends` back a `response` (status code, headers, and data).

- **Common Response Elements**
      - Status Code: HTTP status (e.g., 200 OK, 404 Not Found, 500 Internal Server Error).
      - Headers: Metadata about the response.
      - Body: The actual returned data (usually in JSON or XML format).

## 1. HTTP Basics

### 1.1 HTTP Methods

HTTP methods define the type of action you want to perform on a resource.

- **GET** – Retrieve data from the server (read-only, no side effects).
- **POST** – Send new data to the server (creates a new resource).
- **PUT** – Update an entire resource on the server.
- **PATCH** – Update part of a resource (partial update).
- **DELETE** – Remove a resource from the server.
- **OPTIONS** – Check which HTTP methods are available for a resource.
- **HEAD** – Same as GET, but returns only headers (no response body).

---

### 1.2 HTTP Status Codes

Status codes indicate the result of the HTTP request and are grouped by their first digit.

---

- **2xx (Success)**

  - `200 OK` – Request processed successfully.
  - `201 Created` – Resource created successfully.
  - `202 Accepted` – Request accepted for processing, but not completed yet.
  - `204 No Content` – Request succeeded, but no data returned.

---

- **3xx (Redirection)**

  - `301 Moved Permanently` – Resource has been permanently moved to a new URL.
  - `302 Found` – Temporary redirect.
  - `304 Not Modified` – Resource has not changed since last request (used in caching).

---

- **4xx (Client Errors)**

  - `400 Bad Request` – Invalid request syntax or parameters.
  - `401 Unauthorized` – Authentication required or failed.
  - `403 Forbidden` – Client is authenticated but not allowed to access the resource.
  - `404 Not Found` – Resource not found.
  - `405 Method Not Allowed` – Request method is not supported for the resource.
  - `429 Too Many Requests` – Client sent too many requests in a short period (rate limiting).

---

- **5xx (Server Errors)**

  - `500 Internal Server Error` – Generic server-side error.
  - `502 Bad Gateway` – Server received an invalid response from an upstream server.
  - `503 Service Unavailable` – Server is temporarily down or overloaded.
  - `504 Gateway Timeout` – Server did not receive a timely response from another server.

---

### 1.3 HTTP Headers

HTTP headers provide **metadata** about a request or response. They are sent as key-value pairs and can control how data is processed, cached, authenticated, or presented.

#### **A. Request Headers**

Headers sent **from client to server**.

1. **Content-Type**
    - Describes the format of the request body.
    - Common values:
        - `application/json` – JSON data
        - `application/x-www-form-urlencoded` – Form data
        - `multipart/form-data` – File uploads
        - `text/plain` – Plain text
    - Example:

    ```js
    Content-Type: application/json
    ```

2. **Authorization**
    - Sends authentication credentials.
    - Common schemes:
        - `Bearer <token>` – Token-based authentication (JWT, OAuth)
        - `Basic <base64>` – Username and password (less secure)
        - `ApiKey <key>` – Custom API key
    - Example:

    ```js
    Authorization: Bearer eyJhbGciOiJIUzI1NiIs...
    ```

3. **Accept**
    - Specifies the content format the client expects from the server.
    - Example:

    ```js
    Accept: application/json
    ```

4. **User-Agent**
    - Identifies the client application or browser making the request.
    - Example:

    ```js
    User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)
    ```

5. **Cookie**
    - Sends cookies from the browser to the server for session tracking.
    - Example:

    ```js
    Cookie: sessionId=abc123; theme=dark
    ```

---

#### **B. Response Headers**

Headers sent **from server to client**.

1. **Content-Type**
    - Specifies the format of the response body.
    - Example:

    ```js
    Content-Type: application/json
    ```

2. **Content-Length**
    - The size of the response body in bytes.
    - Example:

    ```js
    Content-Length: 256
    ```

3. **Cache-Control**
    - Controls caching behavior.
    - Examples:

    ```js
    Cache-Control: no-cache
    Cache-Control: max-age=3600
    ```

4. **Set-Cookie**
    - Sends cookies from the server to the client.
    - Example:

    ```js
    Set-Cookie: sessionId=abc123; HttpOnly; Secure
    ```

5. **Access-Control-Allow-Origin** (CORS)
    - Defines which origins are allowed to access the resource.
    - Example:

    ```js
    Access-Control-Allow-Origin: *
    ```

---

#### **C. Custom Headers**

- Developers can create **custom headers** prefixed with `X-` or any name.
- Example:
      - X-Request-ID – Track requests across systems.
      - X-API-Version – Indicate API version used.
      - X-Client-Type – Identify app type (mobile, web, etc.).

---

## 2. Parameters (Path, Query and Body Param)

Parameters provide additional information for the server to process a request. They can be sent in the **URL** or **request body**, depending on the API design.

### 2.1 Path Parameters

- **Definition** – Variable parts of the URL path used to identify **specific resources**. Defined in API documentation with placeholders like `/users/{id}`.
- **Purpose** – Ideal for resource identification when the parameter is essential to the path.
- **Visibility** – Always visible in the URL.
- **Characteristics**:
      - Fixed position in the URL
      - Usually required
      - Cannot contain spaces (must be URL-encoded if special characters are needed)
- **Example:**

```bash
GET /users/123  
```

**Breakdown:**
      - `123` → ID of the user to fetch.  

Path parameters are often defined in API documentation like: `/users/{id}`

### 2.2 Query Parameters

- **Definition** – Appended to the end of a URL after a `?`, with multiple parameters separated by `&`.
- **Purpose** – Commonly used for:
      - Filtering results (e.g., `status=active`)
      - Searching (e.g., `search=keyword`)
      - Pagination (e.g., `page=2&limit=10`)
      - Sorting (e.g., `sort=asc`)
      - Optional configuration settings
- **Visibility** – Visible in the browser's address bar and easy to share or bookmark.
- **Data Types** – Strings, numbers, booleans, arrays (comma-separated or repeated keys).
- **Example:**

```bash
GET /users?page=2&limit=10&sort=desc&status=active
```

- **Breakdown:**
      - `page=2` → Second page of results
      - `limit=10` → Limit each page to 10 results
      - `sort=desc` → Sort results in descending order
      - `status=active` → Return only active users

### 2.3 Request Body

- **Definition** – The main content payload sent with HTTP requests (mainly POST, PUT, PATCH) containing data for processing.
- **Purpose** – Used when sending:
      - Structured data (e.g., user profile details)
      - Bulk data (e.g., file uploads)
      - Sensitive data (avoiding URL exposure)
- **Formats** – Commonly `application/json`, `application/xml`, `multipart/form-data` (file uploads), `application/x-www-form-urlencoded` (HTML form submissions).
- **Visibility** – Not visible in the URL; sent as the request payload.
- **Structure** – Can contain:
        - Strings, numbers, booleans
        - Arrays and nested objects
- **Example (JSON)**:

```json
POST /users
Content-Type: application/json

{
"name": "John Doe",
"email": "john@example.com",
"age": 29,
"roles": ["admin", "editor"],
"address": {
    "street": "123 Main Street",
    "city": "New York",
    "zip": "10001"
  }
}
```

**Breakdown:**
      - `"name"` and `"email"` → Basic user info
      - `"age"` → Integer field
      - `"roles"` → Array of role names
      - `"address"` → Nested object for location details

---

### Key Differences

| Parameter Type   | Location             | Common Use Cases                 | Visible in URL? |
| ---------------- | -------------------- | -------------------------------- | --------------- |
| Query Parameters | After `?` in URL     | Filtering, sorting, pagination   | ✅ Yes          |
| Path Parameters  | Inside the URL path  | Resource identification          | ✅ Yes          |
| Request Body     | HTTP request payload | Sending structured or large data | ❌ No           |

## 3. API Types

### 3.1 REST APIs (RESTful Apis)

- **What is REST** – Representational State Transfer is an architectural style that defines a set of constraints and principles for designing web services.
- **Format** – Primarily use JSON for data exchange, though XML and other formats are also possible.
- **Structure** – Built around standard HTTP methods (GET, POST, PUT, PATCH, DELETE) and clearly defined resource URLs.
- **Resource Based** – resources, which can be data or services available on the server have a unique identifier, URI(Uniform Resource Identifier)
- **Statelessness** – Each request is independent and contains all necessary information; the server does not store client session data between requests.
- **Client-Server Architecture** – Client and server operate independently, allowing each other to be developed and replaced independently.
- **Scalability** – REST APIs are widely used due to their simplicity and scalability in distributed systems.
- **Common Usage** – Suitable for most CRUD operations, integrations, and data-driven applications.

---

### 3.2 WebSockets

- **Purpose** – Enables full-duplex, real-time communication between client and server.
- **How it Works** – Establishes a persistent connection after an initial HTTP handshake, allowing both sides to send and receive messages at any time without re-establishing connections.
- **Advantages** – Low latency, efficient for continuous data exchange, reduces the overhead of repeated HTTP requests.
- **Common Usage** – Ideal for use cases that require instant updates, such as:
  - Chat and messaging applications
  - Live notifications or alerts
  - Multiplayer online games
  - Real-time analytics dashboards

---

## 4. Fetch API vs Axios for HTTP Requests

### 🔹 Introduction to Fetch API

```jsx
useEffect(() => {
  fetch('https://api.example.com/data')
    .then(response => response.json())
    .then(data => console.log(data))
    .catch(error => console.error(error));
}, []);
```

### 🔹 Using Axios for API Requests

```bash
npm install axios
```

```jsx
import axios from 'axios';

useEffect(() => {
  axios.get('https://api.example.com/data')
    .then(response => console.log(response.data))
    .catch(error => console.error(error));
}, []);
```

### 🔹 Pros and Cons of Fetch API vs Axios

| Feature             | Fetch API | Axios    |
| ------------------- | --------- | -------- |
| Default in browser  | ✅ Yes     | ❌ No     |
| Interceptors        | ❌ No      | ✅ Yes    |
| JSON auto transform | ❌ No      | ✅ Yes    |
| Error handling      | Manual    | Built-in |

### 🔹 Setting Up Axios Interceptors

```jsx
axios.interceptors.request.use(config => {
  config.headers.Authorization = `Bearer token`;
  return config;
});
```

---

## 5. Handling Promises & Async/Await

### 🔹 Using Promises with `.then()`

```jsx
fetch(url)
  .then(res => res.json())
  .then(data => console.log(data))
  .catch(err => console.error(err));
```

### 🔹 Writing Asynchronous Code with `async/await`

```jsx
const fetchData = async () => {
  try {
    const res = await fetch(url);
    const data = await res.json();
    console.log(data);
  } catch (err) {
    console.error(err);
  }
};
```

### 🔹 Error Handling in Async Functions

```jsx
try {
  // code
} catch (error) {
  console.error('API error:', error);
}
```

### 🔹 Best Practices

- Always handle errors
- Use `try/catch` inside async functions
- Keep async logic out of render

---

## 6. useEffect with API Calls

### 🔹 Fetching Data Inside `useEffect`

```jsx
useEffect(() => {
  async function loadData() {
    const res = await fetch(url);
    const data = await res.json();
    setData(data);
  }
  loadData();
}, []);
```

### 🔹 Dependency Array and Performance

- Use dependencies wisely to avoid infinite loops
- Avoid unnecessary re-renders

### 🔹 Cleanup Functions

```jsx
useEffect(() => {
  const controller = new AbortController();
  fetch(url, { signal: controller.signal });
  return () => controller.abort();
}, []);
```

### 🔹 Preventing Memory Leaks

- Use `AbortController`
- Track component mounted state with `let isMounted = true`

---

## 7. Handling API Errors and Loading States

### 🔹 Error Handling Best Practices

- Graceful fallbacks
- Display user-friendly messages

### 🔹 Showing Loading Spinners

```jsx
{loading ? <Spinner /> : <DataView data={data} />}
```

### 🔹 Retry Logic

- Use exponential backoff strategy
- Retry with a maximum count

### 🔹 Handling Rate Limits

- Respect API rate limits
- Use headers like `Retry-After`

---
