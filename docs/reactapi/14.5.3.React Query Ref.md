---
date: 
  created: 2025-08-12
---

# React Query References

## React Query — API Reference Overview

To know more check TanStack Documentation here are links:

| API | Purpose / Definition |
| --- | --- |
| **[1. QueryClientProvider](https://tanstack.com/query/latest/docs/framework/react/reference/QueryClientProvider)** | Root provider for React Query. Must wrap your app for queries to work. |
| **[2. useQuery](https://tanstack.com/query/latest/docs/framework/react/reference/useQuery)** | Core hook for fetching, caching, and updating server data. |
| **[3. useMutation](https://tanstack.com/query/latest/docs/framework/react/reference/useMutation)** | Hook for performing create, update, or delete operations. |
| **[4. useQueryClient](https://tanstack.com/query/latest/docs/framework/react/reference/useQueryClient)** | Access and manipulate the query cache manually. |
| **[5 . useQueries](https://tanstack.com/query/latest/docs/framework/react/reference/useQueries)** | Run multiple independent queries in parallel. |
| **[6. useInfiniteQuery](https://tanstack.com/query/latest/docs/framework/react/reference/useInfiniteQuery)** | Manage pagination or infinite scrolling of data. |
| **[7. useIsFetching](https://tanstack.com/query/latest/docs/framework/react/reference/useIsFetching)** | Track ongoing query fetch operations globally. |
| **[8. useIsMutating](https://tanstack.com/query/latest/docs/framework/react/reference/useIsMutating)** | Track ongoing mutation operations globally. |
| **[9. useMutationState](https://tanstack.com/query/latest/docs/framework/react/reference/useMutationState)** | Track mutation states globally. |
| **[10. usePrefetchQuery](https://tanstack.com/query/latest/docs/framework/react/reference/usePrefetchQuery)** | Preload query data before component mount. |
| **[11. usePrefetchInfiniteQuery](https://tanstack.com/query/latest/docs/framework/react/reference/usePrefetchInfiniteQuery)** | Preload infinite query data before component mount. |
| **[12. useSuspenseQuery](https://tanstack.com/query/latest/docs/framework/react/reference/useSuspenseQuery)** | Suspense-enabled version of `useQuery`. |
| **[13. useSuspenseInfiniteQuery](https://tanstack.com/query/latest/docs/framework/react/reference/useSuspenseInfiniteQuery)** | Suspense-enabled version of `useInfiniteQuery`. |
| **[14. useSuspenseQueries](https://tanstack.com/query/latest/docs/framework/react/reference/useSuspenseQueries)** | Suspense-enabled version of `useQueries`. |
| **[15. useQueryErrorResetBoundary](https://tanstack.com/query/latest/docs/framework/react/reference/useQueryErrorResetBoundary)** | Hook to integrate with error boundaries for queries. |
| **[16. QueryErrorResetBoundary](https://tanstack.com/query/latest/docs/framework/react/reference/QueryErrorResetBoundary)** | Component for handling and resetting query errors. |
| **[17. Hydration Utilities](https://tanstack.com/query/latest/docs/framework/react/guides/ssr)** | Functions for server-side rendering and hydration of queries. |

---

## 1. QueryClientProvider

```tsx
import { QueryClientProvider } from "@tanstack/react-query";
import { ReactQueryDevtools } from "@tanstack/react-query-devtools";

// Create a Client
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      // every defalut query you want to give goes here.
    }
  }
});

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <MyAppComponents />
      {/* if you want to use react query devtools */}
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  );
}
```

---

## 2. useQuery

```js
const {
  data,
  dataUpdatedAt,
  error,
  errorUpdatedAt,
  failureCount,
  failureReason,
  fetchStatus,
  isError,
  isFetched,
  isFetchedAfterMount,
  isFetching,
  isInitialLoading,
  isLoading,
  isLoadingError,
  isPaused,
  isPending,
  isPlaceholderData,
  isRefetchError,
  isRefetching,
  isStale,
  isSuccess,
  isEnabled,
  promise,
  refetch,
  status,
} = useQuery(
  {
    queryKey,
    queryFn,
    gcTime,
    enabled,
    networkMode,
    initialData,
    initialDataUpdatedAt,
    meta,
    notifyOnChangeProps,
    placeholderData,
    queryKeyHashFn,
    refetchInterval,
    refetchIntervalInBackground,
    refetchOnMount,
    refetchOnReconnect,
    refetchOnWindowFocus,
    retry,
    retryOnMount,
    retryDelay,
    select,
    staleTime,
    structuralSharing,
    subscribed,
    throwOnError,
  },
  queryClient,
)
```

---

### React useQuery: Key Options

- {++ **queryKey** ++}
      - Unique key identifying the query in the cache.  
      - Can be a string or array (for dynamic keys).  

- {++ **queryFn** ++}
      - Function that fetches the data.  
      - Must return a promise.  

- {++ **staleTime** ++}
      - Time (ms) that data is considered "fresh."  
      - Default: 0 (data is stale immediately).  

- {++ **cacheTime** ++}
      - Time (ms) that unused data stays in memory before garbage collection.  
      - Default: 5 minutes.  

- {++ **enabled** ++}
      - Boolean to enable/disable the query.  
      - Useful for conditional queries.  

- {++ **refetchOnMount** ++}
      - Controls whether to refetch when the component mounts.  
      - Options: `true | false | 'always'`.  

- {++ **refetchOnWindowFocus** ++}
      - Controls whether to refetch when the browser window gains focus.  
      - Options: `true | false | 'always'`.  

- {++ **refetchOnReconnect** ++}
      - Refetch when the network reconnects.  
      - Options: `true | false | 'always'`.  

- {++ **retry** ++}
      - Number of retry attempts if the query fails.  
      - Can be a number or a function returning a boolean.  
      - Default: 3.  

- {++ **retryDelay** ++}
      - Delay (ms) between retry attempts.  
      - Can be a number or a function.  

- {++ **onSuccess** ++}
      - Callback fired when the query succeeds.  

- {++ **onError** ++}
      - Callback fired when the query fails.  

- {++ **onSettled** ++}
      - Callback fired when the query finishes, regardless of success or error.  

- {++ **select** ++}
      - Transform or map the fetched data before returning it.  

- {++ **initialData** ++}
      - Provides default data before the query resolves.  

- {++ **placeholderData** ++}
      - Data to display while the query is loading.  

- {++ **keepPreviousData** ++}
      - Keeps previous query data while fetching new data (useful for pagination).  

- {++ **structuralSharing** ++}
      - Controls how updates to data affect reference equality (default: shallow).  

- {++ **refetchInterval** ++}
      - Automatically refetch the query every X ms.  
      - Can be a number or `false` to disable.  

- {++ **refetchIntervalInBackground** ++}
      - If true, refetch interval continues even when the window is not focused.  

- {++ **onSettled** ++}
      - Callback that runs after the query completes (success or error).  

---

### React useQuery: Returns

- {++ **data**++}
      - The resolved data from the query function.
      - `undefined` if data hasn’t been fetched yet.

- {++ **error**++}
      - The error object if the query fails.
      - `null` if no error.

- {++ **isLoading**++}
      - `true` while the query is in its initial loading state.
      - Only true on the first fetch.

- {++ **isFetching**++}
      - `true` whenever the query is fetching data (initial or background refetch).
      - Useful to show loading indicators even on background updates.

- {++ **isError**++}
      - `true` if the query has encountered an error.

- {++ **isSuccess**++}
      - `true` if the query successfully fetched data.

- {++ **isIdle**++}
      - `true` if the query is disabled (`enabled: false`) and hasn’t run yet.

- {++ **refetch**++}
      - Function to manually refetch the query.

- {++ **status**++}
      - Overall status of the query: `"idle" | "loading" | "error" | "success"`.

- {++ **failureCount**++}
      - Number of times the query has failed.

- {++ **isFetched**++}
      - `true` if the query has been fetched at least once, regardless of success or error.

- {++ **isFetchedAfterMount**++}
      - `true` if the query has been fetched after the component mounted.

- {++ **dataUpdatedAt**++}
      - Timestamp (ms) when the data was last updated.

- {++ **errorUpdatedAt**++}
      - Timestamp (ms) when the error was last updated.

- {++ **remove**++}
      - Function to manually remove the query from the cache.

- {++ **refetchOnWindowFocus**++}
      - Boolean indicating if the query will refetch when the window regains focus (from options).

- {++ **refetchOnReconnect**++}
      - Boolean indicating if the query will refetch when network reconnects.

- {++ **isStale**++}
      - Boolean indicating whether the data is stale according to `staleTime`.

- {++ **isPlaceholderData**++}
      - Boolean indicating whether the query is using placeholder data.

- {++ **isPreviousData**++}
      - Boolean indicating whether the data is from a previous query while fetching new data.

---

## 3. useMutation

**Purpose**:  
Used to perform mutations (create, update, delete operations) against a server or API. Unlike `useQuery`, it does not run automatically — you trigger it manually.

```js
const {
  data,
  error,
  failureCount,
  failureReason,
  isError,
  isIdle,
  isPending,
  isPaused,
  isSuccess,
  isLoading,
  mutate, 
  mutateAsync,
  reset,
  status,
  submittedAt,
} = useMutation(
  {
    mutationFn,
    mutationKey,
    gcTime,
    networkMode,
    meta,
    onMutate,
    onSuccess,
    onError,
    onSettled,
    retry,
    retryDelay,
    throwOnError,
  },
  // (Optional) QueryClient instance
  queryClient
)
```

---

### React useMutation: Key Options

- {++ **mutationFn** → *(Function)* ++}
      - The function that performs the mutation (e.g., POST, PUT, DELETE request).

- {++ **mutationKey** → *(Optional, Array | String)* ++}
      - Unique key to identify the mutation. Helps with caching and devtools.

- {++ **onMutate** → *(Callback)* ++}
      - Runs **before the mutation function**. Useful for optimistic updates.  
      - `(variables) => context`

- {++ **onSuccess** → *(Callback)* ++}
      - Runs **when the mutation succeeds**.  
      - `(data, variables, context) => void`

- {++ **onError** → *(Callback)* ++}
      - Runs **if the mutation fails**.  
      - `(error, variables, context) => void`

- {++ **onSettled** → *(Callback)* ++}
      - Runs **after mutation is either success or error**.  
      - `(data, error, variables, context) => void`

- {++ **retry** → *(Boolean | Number | Function)* ++}
      - Number of retry attempts if the mutation fails. Default: `false`.

- {++ **retryDelay** → *(Number | Function)* ++}
      - Delay between retries in ms.

- {++ **useErrorBoundary** → *(Boolean | (error) => boolean)* ++}
      - Whether to propagate mutation errors to an error boundary.

- {++ **meta** → *(Object)* ++}
      - Arbitrary metadata you can attach to the mutation.

- {++ **networkMode** → *(string)* ++}
      - Control when the mutation runs: `"online"`, `"always"`, etc.

- {++ **gcTime** → *(number)* ++}
      - Time in ms before inactive mutations are garbage collected. Default: 5 minutes.

- {++ **scope** → *(string)* ++}
      - Advanced — scope of the mutation for queryClient.

---

### React useMutation: Return Values

The object returned from `useMutation` contains:

- {++ **mutate**++}
      - Function to trigger mutation.  
      - `mutate(variables, { onSuccess, onError, onSettled })`

- {++ **mutateAsync**++}
      -  Promise-based version of `mutate`.  
      - `await mutateAsync(variables)`

- {++ **status**++}
      -  Current status of the mutation.  
      - `"idle" | "pending" | "success" | "error"`

- {++ **data**++}
      -  Data returned from the mutation (on success).

- {++ **error**++}
      -  Error object (if mutation fails).

- {++ **isIdle**++}
      -  `true` if mutation has not started.

- {++ **isPending**++}
      -  `true` if mutation is in progress.

- {++ **isLoading**++}
      -  Alias for `isPending`.

- {++ **isSuccess**++}
      -  `true` if mutation succeeded.

- {++ **isError**++}
      -  `true` if mutation failed.

- {++ **variables**++}
      -  The last variables passed into `mutate`.

- {++ **submittedAt**++}
      -  Timestamp of the last mutation trigger.

- {++ **context**++}
      -  The value returned from `onMutate`.

- {++ **reset**++}
      -  Reset mutation state back to `idle`.

---

## 4. useQueryClient

**Purpose**:  
`useQueryClient` is a React Query hook that provides direct access to the **QueryClient instance**.  
The `QueryClient` is the core manager that stores, manages, and controls all queries and mutations in your app.  
By using this hook, you can **imperatively interact** with cached data, trigger refetches, reset or remove queries, and control mutations globally.  

This is especially useful for:  

- **Optimistic Updates** (update cache before server responds)  
- **Manual Cache Manipulation** (set, update, or clear data without a query running)  
- **Global Invalidations** (e.g., when user logs out, clear sensitive queries)  
- **Prefetching Data** before navigation  
- **Managing Mutations** at a global level  

```js
import React from "react";
import { useQuery, useQueryClient } from "@tanstack/react-query";

// Fake API
const fetchTodos = async () => {
  const res = await fetch("https://jsonplaceholder.typicode.com/todos?_limit=3");
  return res.json();
};

export default function TodoApp() {
  const queryClient = useQueryClient();

  // Normal query
  const { data: todos } = useQuery({
    queryKey: ["todos"],
    queryFn: fetchTodos,
  });

  // Example handler that uses multiple queryClient methods
  const handleActions = async () => {
    // 1️⃣ Get cached data
    const existing = queryClient.getQueryData(["todos"]);
    console.log("Existing cached data:", existing);

    // 2️⃣ Set cached data (optimistic update)
    queryClient.setQueryData(["todos"], (old: any) => [
      ...(old || []),
      { id: Date.now(), title: "New Optimistic Todo", completed: false },
    ]);

    // 3️⃣ Invalidate queries (refetch in background)
    queryClient.invalidateQueries({ queryKey: ["todos"] });

    // 4️⃣ Prefetch (store in cache without using immediately)
    await queryClient.prefetchQuery({
      queryKey: ["todo", 1],
      queryFn: () =>
        fetch("https://jsonplaceholder.typicode.com/todos/1").then((r) =>
          r.json()
        ),
    });

    // 5️⃣ Fetch query imperatively (returns data)
    const todo1 = await queryClient.fetchQuery({
      queryKey: ["todo", 1],
      queryFn: () =>
        fetch("https://jsonplaceholder.typicode.com/todos/1").then((r) =>
          r.json()
        ),
    });
    console.log("Fetched todo1:", todo1);

    // 6️⃣ Cancel in-flight queries
    await queryClient.cancelQueries({ queryKey: ["todos"] });

    // 7️⃣ Reset queries (clear state + refetch if active)
    queryClient.resetQueries({ queryKey: ["todos"] });

    // 8️⃣ Remove queries (clear completely from cache)
    queryClient.removeQueries({ queryKey: ["todo", 1] });
  };

  return (
    <div className="p-4">
      <h2>Todos</h2>
      <button
        onClick={handleActions}
        className="bg-blue-500 text-white px-3 py-1 rounded"
      >
        Run QueryClient Actions
      </button>
      <ul>
        {todos?.map((todo: any) => (
          <li key={todo.id}>
            {todo.title} {todo.completed ? "✅" : "❌"}
          </li>
        ))}
      </ul>
    </div>
  );
}
```

### 🔑 Key Methods on QueryClient

#### 1. **getQueryData(queryKey)**  

- Retrieves cached data for a specific query key.  
- Returns `undefined` if no cache exists.  
- Useful for reading current data without triggering a network request.  

#### 2. **setQueryData(queryKey, updaterFnOrData)**  

- Manually sets or updates the cached data for a query.  
- `updaterFnOrData` can be:  
  - Direct data → replaces the cache.  
  - Function → receives the previous value and returns the new one.  
- Used for **optimistic updates** (update UI immediately).  

#### 3. **fetchQuery(queryKey, queryFn, options?)**  

- Executes a query function and caches the result.  
- Will fetch from network if cache is stale or missing.  
- Returns a promise with the resolved data.  

#### 4. **prefetchQuery(queryKey, queryFn, options?)**  

- Similar to `fetchQuery` but intended for **warming up the cache**.  
- Doesn’t return data directly to components, just caches it.  
- Commonly used for **preloading data before navigation**.  

#### 5. **invalidateQueries(queryKey?, options?)**  

- Marks queries as **stale**, forcing them to refetch the next time they are used.  
- Can be called with:  
  - A specific key → invalidates only that query.  
  - No key → invalidates all queries.  
- Useful after a mutation to refresh related data.  

#### 6. **removeQueries(queryKey?, options?)**  

- Completely removes queries from the cache.  
- Unlike invalidation, this **deletes** them (they won’t refetch unless mounted again).  
- Useful for clearing sensitive or outdated data.  

#### 7. **resetQueries(queryKey?, options?)**  

- Resets queries back to their initial state (`idle`).  
- They will refetch automatically if mounted.  
- Often used when a user logs out and you want a fresh state.  

#### 8. **cancelQueries(queryKey?, options?)**  

- Cancels any in-flight (ongoing) requests for queries.  
- Can target a specific query or all queries.  
- Useful when navigating away from a page or avoiding duplicate requests.  

#### 9. **refetchQueries(queryKey?, options?)**  

- Manually refetches queries from the server.  
- Can refetch one query, multiple queries, or all queries.  
- Useful after actions like refreshing a dashboard or pulling latest data.  

#### 10. **getQueriesData(queryKey?)**  

- Returns an array of `[queryKey, data]` tuples for all cached queries matching the filter.  
- Helps inspect all cached values at once.  

#### 11. **clear()**  

- Clears the **entire query + mutation cache**.  
- All data is lost and queries will refetch if mounted again.  
- Commonly used when logging out or resetting the app state.  

#### 12. **setMutationDefaults(mutationKey, options)**  

- Set default options (like retry, onSuccess, etc.) for mutations with a specific key.  
- Helps apply consistent mutation behavior across the app.  

#### 13. **getMutationCache()**  

- Gives direct access to the internal **mutation cache**.  
- Advanced usage: manually inspect or manipulate mutation states.  

### 📦 Return Value

- `useQueryClient` returns the **singleton QueryClient instance** created at the app root (inside `QueryClientProvider`).  
- This single client instance is shared across your entire React app.  
- By using this, you can **globally control queries and mutations**, without needing access to the component that created them.  

---

## 5. useQueries

**Purpose**:  
`useQueries` is a React Query hook that allows you to run **multiple queries in parallel** inside a component.  
Instead of calling `useQuery` multiple times, you can batch them together in a single hook for better readability and easier management.  

This is useful when:  

- You need to fetch **different data sources at once** (e.g., user info + posts + comments).  
- You want **consistent handling** of multiple queries with shared options.  
- You want to dynamically create queries from an array.  

---

### 🔑 Usage Structure

```js
const [userQuery, postsQuery, commentsQuery] = useQueries({
  queries: [
    {
      queryKey: ['user', userId],
      queryFn: () => fetchUser(userId),
      enabled: true,
      staleTime: 1000 * 60, // 1 min
    },
    {
      queryKey: ['posts', userId],
      queryFn: () => fetchPosts(userId),
      retry: 2,
    },
    {
      queryKey: ['comments', userId],
      queryFn: () => fetchComments(userId),
    },
  ],
})
```

### Options

Each query object inside the `queries` array accepts the same options as `useQuery`:

- **queryKey (Required)** → Unique identifier for the query.  
- **queryFn (Required)** → Function that returns a promise of data.  
- **enabled (Boolean)** → Controls whether the query runs automatically.  
- **staleTime (Number)** → Time (in ms) before cached data is considered stale.  
- **cacheTime (Number)** → Duration (in ms) inactive queries remain in cache.  
- **retry / retryDelay (Number | Boolean | Function)** → Retry behavior for failed queries.  
- **networkMode (String)** → Execution mode: `"online"` | `"always"`.  
- **meta (Object)** → Arbitrary metadata for debugging/devtools.  
- **select (Function)** → Transform or filter data before returning it.  
- **onSuccess / onError / onSettled (Callbacks)** → Lifecycle handlers for side effects.  

### Return Value

`useQueries` returns an **array of query results**, one for each query object.  
Each result has the same structure as a `useQuery` result:

- **data** → Cached or freshly fetched data.  
- **error** → Error object if the query failed.  
- **status** → `"idle"` | `"pending"` | `"success"` | `"error"`.  
- **isLoading** → `true` if the query is fetching for the first time.  
- **isFetching** → `true` if background fetching is in progress.  
- **isSuccess / isError / isIdle** → Boolean states of the query.  
- **refetch()** → Function to manually re-run the query.  

---

## 6. useInfiniteQuery

```js
import { useInfiniteQuery } from "@tanstack/react-query"
import axios from "axios"

const fetchPosts = async ({ pageParam = 1, signal }) => {
  const res = await axios.get(
    `https://jsonplaceholder.typicode.com/posts?_page=${pageParam}&_limit=10`,
    { signal }
  )
  return res.data
}

export default function Example() {
  const query = useInfiniteQuery({
    queryKey: ["posts"],              // Unique key for cache
    queryFn: fetchPosts,              // Async function
    getNextPageParam: (lastPage, allPages) => {
      // Define how to fetch next page
      if (lastPage.length === 0) return undefined
      return allPages.length + 1
    },
    getPreviousPageParam: (firstPage, allPages) => {
      // Optional: define how to fetch previous page
      return allPages.length > 1 ? allPages.length - 1 : undefined
    },
    initialPageParam: 1,              // Default page to start
    maxPages: 5,                      // Optional: keep only limited pages in cache
    retry: 3,                         // Retry failed queries
    retryDelay: (attempt) => attempt * 1000,
    refetchOnMount: true,
    refetchOnWindowFocus: true,
    refetchOnReconnect: true,
    staleTime: 1000 * 60,             // 1 min cache freshness
    cacheTime: 1000 * 60 * 5,         // 5 min keep unused data
    enabled: true,                    // Run automatically
    suspense: false,                  // For Suspense mode
    networkMode: "online",            // online | always | offlineFirst
    meta: { source: "demo" },         // Custom metadata
    select: (data) => data,           // Transform data if needed
    structuralSharing: true,          // Shallow merge new data
    throwOnError: false,              // Throw errors or not
  })

  // ✅ All return values available
  console.log({
    data: query.data,                        // Pages of data
    pages: query.data?.pages,                // Array of pages
    pageParams: query.data?.pageParams,      // Params for each page
    error: query.error,                      // Error object
    fetchNextPage: query.fetchNextPage,      // Function to load more
    fetchPreviousPage: query.fetchPreviousPage, // Load previous
    hasNextPage: query.hasNextPage,          // Boolean
    hasPreviousPage: query.hasPreviousPage,  // Boolean
    isFetching: query.isFetching,
    isFetchingNextPage: query.isFetchingNextPage,
    isFetchingPreviousPage: query.isFetchingPreviousPage,
    isLoading: query.isLoading,
    isError: query.isError,
    isSuccess: query.isSuccess,
    status: query.status,                    // loading | error | success
    refetch: query.refetch,                  // Manual refetch
  })

  return null
}
```

The **useInfiniteQuery** hook is used for handling **paginated or infinite scrolling data**. Instead of fetching a fixed set of results, it allows you to fetch data page by page and append new results seamlessly.

### Key Options for InfiniteQuery

- **queryKey (Required)** → Unique identifier for the query.  
- **queryFn (Required)** → Function that fetches a page of data.  
- **getNextPageParam (Required)** → Function that returns the next page parameter from the last page’s data.  
- **initialPageParam (Optional)** → The initial parameter to start fetching from (default: `undefined`).  
- **enabled (Boolean)** → Whether the query should run automatically.  
- **staleTime (Number)** → Time in ms before cached data is considered stale.  
- **cacheTime (Number)** → Time inactive queries stay in cache.  
- **retry / retryDelay (Number | Boolean | Function)** → Retry logic if query fails.  
- **select (Function)** → Transform paginated data before returning.  
- **onSuccess / onError / onSettled (Callbacks)** → Lifecycle handlers.

### Return Value for InfiniteQuery

useInfiniteQuery returns an object similar to useQuery, but with pagination helpers:

- **data.pages** → Array of pages fetched so far.  
- **data.pageParams** → Parameters used for each page fetched.  
- **fetchNextPage()** → Function to fetch the next page.  
- **fetchPreviousPage()** → Function to fetch the previous page (if supported).  
- **hasNextPage** → Boolean indicating if there’s another page to fetch.  
- **hasPreviousPage** → Boolean indicating if a previous page exists.  
- **isFetchingNextPage** → True if the next page is currently being fetched.  
- **isFetchingPreviousPage** → True if the previous page is currently being fetched.  
- **status, data, error, isLoading, isError, isSuccess** → Same as useQuery states.  

---

## 7. useIsFetching

`useIsFetching` is a React Query hook that tracks the number of active queries that are currently fetching (in-flight).  
It can be used to show global loading indicators or trigger UI changes based on query activity.

```js
import React from "react";
import {
  useQuery,
  useIsFetching,
  useQueryClient,
  QueryClient,
  QueryClientProvider,
} from "@tanstack/react-query";

const queryClient = new QueryClient();

const fetchUsers = async () => {
  const res = await fetch("https://jsonplaceholder.typicode.com/users");
  return res.json();
};

const fetchPosts = async () => {
  const res = await fetch("https://jsonplaceholder.typicode.com/posts");
  return res.json();
};

function Dashboard() {
  // Queries
  const usersQuery = useQuery({
    queryKey: ["users"],
    queryFn: fetchUsers,
  });

  const postsQuery = useQuery({
    queryKey: ["posts"],
    queryFn: fetchPosts,
  });

  // useIsFetching with no args → counts all active fetches
  const isFetchingAll = useIsFetching();

  // useIsFetching with queryKey
  const isFetchingUsers = useIsFetching({ queryKey: ["users"] });
  const isFetchingPosts = useIsFetching({ queryKey: ["posts"] });

  // useIsFetching with filters (status, exact)
  const isFetchingUsersExact = useIsFetching({
    queryKey: ["users"],
    exact: true,
  });

  const isFetchingByStatus = useIsFetching({
    predicate: (query) => query.state.status === "loading",
  });

  return (
    <div>
      <h2>Dashboard</h2>

      <p>Total active fetches: {isFetchingAll}</p>
      <p>Users fetching: {isFetchingUsers}</p>
      <p>Posts fetching: {isFetchingPosts}</p>
      <p>Users (exact) fetching: {isFetchingUsersExact}</p>
      <p>Fetching by status (loading): {isFetchingByStatus}</p>

      <hr />
      <h3>Users</h3>
      {usersQuery.isLoading && <p>Loading users...</p>}
      {usersQuery.data?.map((user: any) => (
        <p key={user.id}>{user.name}</p>
      ))}

      <h3>Posts</h3>
      {postsQuery.isLoading && <p>Loading posts...</p>}
      {postsQuery.data?.slice(0, 5).map((post: any) => (
        <p key={post.id}>{post.title}</p>
      ))}
    </div>
  );
}

export default function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <Dashboard />
    </QueryClientProvider>
  );
}
```

---

### 🔑 Options (Parameters)

The hook accepts an **optional filters object**:

- **queryKey?: QueryKey**  
  - Filter by query key.  
  - Matches queries with the given key or part of it.

- **exact?: boolean**  
  - If `true`, only queries with an exact match of `queryKey` are counted.  
  - Defaults to `false`.

- **predicate?: (query: Query) => boolean**  
  - A custom function to filter queries.  
  - Receives the query object, returns `true` if it should be counted.

---

### 🔄 Return Value

- **number**  
  - Returns the total count of queries that are currently fetching and match the filters.  
  - If no filters are provided, it returns the count of **all active fetching queries**.

---

## 8. useIsMutating

`useIsMutating` is a React Query hook that tracks the number of active mutations currently running.  
It’s useful for showing global mutation indicators (e.g., "Saving..." spinners).

```js
import React from "react";
import { useMutation, useIsMutating, useQueryClient } from "@tanstack/react-query";

function SaveProfileButton() {
  const queryClient = useQueryClient();

  // Example mutation: save profile
  const saveProfileMutation = useMutation({
    mutationKey: ["saveProfile"],
    mutationFn: async (profileData: { name: string }) => {
      await new Promise((resolve) => setTimeout(resolve, 2000)); // simulate API delay
      return profileData;
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: ["profile"] });
    },
  });

  // Count all active mutations
  const totalMutations = useIsMutating();

  // Count only "saveProfile" mutations
  const profileMutations = useIsMutating({ mutationKey: ["saveProfile"] });

  // Count mutations with custom filter
  const customFilteredMutations = useIsMutating({
    predicate: (mutation) => mutation.options.mutationKey?.[0] === "saveProfile",
  });

  return (
    <div>
      <button
        onClick={() => saveProfileMutation.mutate({ name: "Sourav" })}
        disabled={saveProfileMutation.isPending}
        className="px-4 py-2 rounded bg-blue-600 text-white"
      >
        {saveProfileMutation.isPending ? "Saving..." : "Save Profile"}
      </button>

      <p>Total active mutations: {totalMutations}</p>
      <p>Active profile mutations: {profileMutations}</p>
      <p>Custom filtered mutations: {customFilteredMutations}</p>
    </div>
  );
}

export default SaveProfileButton;
```

### Options for useIsMutating

The hook accepts an **optional filters object**:

- **mutationKey?: MutationKey**  
  - Filter by mutation key.  
  - Matches mutations with the given key or part of it.

- **exact?: boolean**  
  - If `true`, only mutations with an exact match of `mutationKey` are counted.  
  - Defaults to `false`.

- **predicate?: (mutation: Mutation) => boolean**  
  - A custom function to filter mutations.  
  - Receives the mutation object, returns `true` if it should be counted.

### Return Value for useIsMutating

- **number**  
  - Returns the total count of mutations that are currently in-flight and match the filters.  
  - If no filters are provided, it returns the count of **all active mutations**.

---

## 9. useMutationState

**Purpose**:  
`useMutationState` is a React Query hook that lets you **subscribe to the state of one or multiple mutations** in the cache. It’s mainly used for **tracking ongoing mutations**, **building global loading indicators**, or **reacting to mutation states outside of the component where `useMutation` is defined**.

```js
const mutationStates = useMutationState({
  filters?: {
    // 🔑 Filters mutations by key
    // Can be a string or array of strings
    // Example: "createUser" or ["user", "create"]
    mutationKey,

    // 🎯 Whether to match the key exactly
    // Default: false
    // true → only exact matches
    // false → allows partial matches
    exact,

    // 📌 Filter mutations by status
    // Accepts a string or array of statuses
    // Options: "idle" | "pending" | "success" | "error"
    // Example: status: ["pending", "error"]
    status,

    // ⚡ Custom filter function
    // Receives the full mutation object
    // Return true to include, false to exclude
    // Example: (mutation) => mutation.state.data?.role === "admin"
    predicate,
  },

  select?: (mutation) => {
    // 🎨 Transform each mutation object before returning
    // mutation → the raw mutation state
    // Return any custom shape you need

    // Example: pick specific fields
    return {
      key: mutation.mutationKey,
      status: mutation.state.status,
      error: mutation.state.error,
      submittedAt: mutation.state.submittedAt,
    }
  },
})

// 📦 Return Value → Always an array of mutation states (possibly empty)
// Each mutation object contains:
mutationStates = [
  {
    mutationKey, // identifier
    state: {
      status,       // "idle" | "pending" | "success" | "error"
      variables,    // variables passed into mutate()
      data,         // response data (if success)
      error,        // error object (if failed)
      submittedAt,  // timestamp of trigger
      context,      // value from onMutate()
    },
  },
  ...
]
```

### React useMutationState: Key Options

- {++ **filters** → *(Object)* ++}  
  Used to filter which mutations you want to subscribe to.  

  - **mutationKey** → *(String | Array)*  
    Filter by specific mutation key(s).  

  - **exact** → *(Boolean)*  
    Match mutation key exactly if `true`.  

  - **status** → *(String | Array)*  
    Filter by mutation status: `"idle" | "pending" | "success" | "error"`.  

  - **predicate** → *(Function)*  
    Custom filter: `(mutation) => boolean`.  

- {++ **select** → *(Function)* ++}  
  Transform or map each mutation state before returning.  
  `(mutation) => transformedResult`  

---

### React useMutationState: Return Value

The return value is always an **array** of matching mutation states.  
Each mutation state object contains:

- {++ **mutationKey**++}  
  The key identifying the mutation.  

- {++ **state**++}  
  Internal state of the mutation, including:  
  - **status** → `"idle" | "pending" | "success" | "error"`  
  - **variables** → Variables used when the mutation was triggered.  
  - **data** → Data returned from the mutation  
  - **error** → Error object if mutation failed  
  - **submittedAt** → Timestamp when the mutation was triggered  

---

## 10. usePrefetchQuery

The `usePrefetchQuery` hook in React Query is used to **preload data into the cache without rendering a component**.  
This is particularly useful for improving **performance and UX** by prefetching data before navigation or interaction.

```js
import { useQueryClient } from "@tanstack/react-query"
import { useEffect } from "react"

// Example fetch function
const fetchUser = async (id: string) => {
  const res = await fetch(`/api/users/${id}`)
  if (!res.ok) throw new Error("Network response was not ok")
  return res.json()
}

export default function PrefetchExample() {
  const queryClient = useQueryClient()

  // Prefetch user data when component mounts
  useEffect(() => {
    queryClient.prefetchQuery({
      queryKey: ["user", "123"],
      queryFn: () => fetchUser("123"),
      staleTime: 1000 * 60 * 5, // 5 minutes
      gcTime: 1000 * 60 * 10, // 10 minutes in cache
    })
  }, [queryClient])

  return (
    <div>
      <h2>Prefetch Example</h2>
      <p>User 123 will be prefetched and cached for later use.</p>
    </div>
  )
}
```

### Options Key

- **queryKey** (required)  
  Unique key to identify the query in the cache.  
  - Type: `Array | string`  
  - Example: `['user', userId]`

- **queryFn** (required)  
  The asynchronous function that fetches the data.  
  - Type: `() => Promise<TData>`  
  - Example: `() => fetchUser(userId)`

- **staleTime**  
  Time (in ms) that the data remains fresh before it becomes stale.  
  - Type: `number`  
  - Default: `0`

- **cacheTime**  
  Time (in ms) inactive queries stay in the cache before garbage collection.  
  - Type: `number`  
  - Default: `5 * 60 * 1000` (5 minutes)

- **retry**  
  Number of retry attempts if the query fails.  
  - Type: `boolean | number`  
  - Default: `3`

- **retryDelay**  
  Delay between retries.  
  - Type: `number | (attempt: number) => number`  
  - Default: exponential backoff

- **meta**  
  Metadata attached to the query (useful for custom logging/debugging).  
  - Type: `object`

### Return Value of usePrefetchQuery

Unlike `useQuery`, `usePrefetchQuery` does **not return query data**.  
It returns a **Promise** that resolves once the data is fetched and stored in the cache.

- **Promise< void>** → resolves when the prefetch is complete.  
- Errors can be caught via `.catch()` if needed.

### Notes

- Typically used with `queryClient` outside components or in event handlers.  
- Improves perceived performance by ensuring data is already available when a user navigates to a new route.

---

## 11. usePrefetchInfiniteQuery

The `usePrefetchInfiniteQuery` hook in React Query allows you to prefetch data for an **infinite query** (a paginated query that loads data page by page).  
It works similarly to `usePrefetchQuery` but is designed for queries that use `useInfiniteQuery`.

```js
import { useQueryClient } from "@tanstack/react-query"
import { useEffect } from "react"

// Example paginated fetch function
const fetchPosts = async ({ pageParam = 1 }) => {
  const res = await fetch(`/api/posts?page=${pageParam}`)
  if (!res.ok) throw new Error("Network error")
  return res.json()
}

export default function PrefetchInfiniteExample() {
  const queryClient = useQueryClient()

  useEffect(() => {
    queryClient.prefetchInfiniteQuery({
      queryKey: ["posts"],
      queryFn: fetchPosts,
      initialPageParam: 1,
      getNextPageParam: (lastPage, allPages) => {
        // Example: return next page number if more data exists
        return lastPage.hasMore ? allPages.length + 1 : undefined
      },
      staleTime: 1000 * 60 * 5, // 5 min
      gcTime: 1000 * 60 * 10,   // 10 min
    })
  }, [queryClient])

  return (
    <div>
      <h2>Prefetch Infinite Query Example</h2>
      <p>Posts are prefetched and ready for infinite scrolling.</p>
    </div>
  )
}
```

### Options Value

- **queryKey**  
  Unique key to identify the query (usually an array).

- **queryFn**  
  The asynchronous function that fetches data.  
  It receives a `context` object containing:
  - `pageParam`: The parameter for the current page.
  - `signal`: Abort signal for cancellation.

- **initialPageParam**  
  The parameter to start with when fetching the first page.

- **getNextPageParam**  
  Function that tells React Query how to get the `pageParam` for the next page.

- **getPreviousPageParam**  
  Function that tells React Query how to get the `pageParam` for the previous page (optional).

- **staleTime**  
  Time (in ms) before data is considered stale.

- **gcTime**  
  Time (in ms) before unused data is garbage collected.

- **retry**  
  Number of retry attempts if the fetch fails.

- **retryDelay**  
  Delay (in ms) between retries.

- **enabled**  
  Boolean to control whether the query should run automatically.

- **select**  
  Function to transform or filter the fetched data before caching.

- **meta**  
  Additional metadata attached to the query.

### Returns

Calling `usePrefetchInfiniteQuery` does not return data directly. Instead, it **prefetches and caches** the infinite query so that when `useInfiniteQuery` is called later with the same key, data is already available.

It returns:

- **promise**  
  Resolves when the data has been fetched and stored in the cache.

---

## 12. useSuspenseQuery

The `useSuspenseQuery` hook is similar to `useQuery`, but it is designed to work with **React Suspense**.  
Instead of returning a loading state (`isLoading`), it will **throw a Promise** that React Suspense can catch, pausing rendering until the data is ready.

```js
import React, { Suspense } from "react";
import { useSuspenseQuery } from "@tanstack/react-query";

async function fetchUser(id: number) {
  const res = await fetch(`https://jsonplaceholder.typicode.com/users/${id}`);
  if (!res.ok) throw new Error("Network response was not ok");
  return res.json();
}

function User({ id }: { id: number }) {
  const { data } = useSuspenseQuery({
    queryKey: ["user", id],
    queryFn: () => fetchUser(id),
  });

  return (
    <div>
      <h2>{data.name}</h2>
      <p>Email: {data.email}</p>
      <p>Phone: {data.phone}</p>
    </div>
  );
}

export default function App() {
  return (
    <Suspense fallback={<div>Loading user...</div>}>
      <User id={1} />
    </Suspense>
  );
}
```

### Option Values

- **queryKey**:  
  A unique key (array or string) that identifies the query.

- **queryFn**:  
  The asynchronous function that fetches and returns data.

- **enabled** *(optional)*:  
  Whether the query should automatically run (`true` by default).

- **staleTime** *(optional)*:  
  Duration (in ms) for which the data is considered fresh.

- **gcTime** *(optional)*:  
  Duration (in ms) after which inactive queries are garbage collected.

- **retry** *(optional)*:  
  Number of retry attempts if the query fails. Default: `3`.

- **retryDelay** *(optional)*:  
  Delay between retries. Can be a number or function.

- **refetchOnMount** *(optional)*:  
  Refetch when the component mounts. (`true`, `false`, or `"always"`).

- **refetchOnWindowFocus** *(optional)*:  
  Refetch when the window regains focus.

- **refetchInterval** *(optional)*:  
  Interval (ms) for background refetching. (`false` to disable).

- **initialData** *(optional)*:  
  Preloaded data to be used before the query runs.

- **select** *(optional)*:  
  Function to transform/derive a subset of the data before returning.

### Return Values

Since it uses Suspense, **loading and error states are not included** in the return.  

- **data**:  
  The resolved data from the query function.  
- **refetch**:  
  Function to manually refetch the query.

---

## 13. useSuspenseInfiniteQuery  

The `useSuspenseInfiniteQuery` hook is similar to `useInfiniteQuery` but designed for **React Suspense**.  
It enables fetching **paginated or infinite lists of data** while letting Suspense handle loading states.  

```js
import React, { Suspense } from "react";
import { useSuspenseInfiniteQuery } from "@tanstack/react-query";
import axios from "axios";

async function fetchPosts({ pageParam = 1 }) {
  const res = await axios.get(
    `https://jsonplaceholder.typicode.com/posts?_limit=5&_page=${pageParam}`
  );
  return res.data;
}

function PostsList() {
  const {
    data,
    fetchNextPage,
    hasNextPage,
    isFetchingNextPage,
  } = useSuspenseInfiniteQuery({
    queryKey: ["posts"],
    queryFn: fetchPosts,
    initialPageParam: 1,
    getNextPageParam: (lastPage, allPages) => {
      return lastPage.length === 5 ? allPages.length + 1 : undefined;
    },
  });

  return (
    <div>
      {data.pages.map((page, i) => (
        <React.Fragment key={i}>
          {page.map((post: any) => (
            <p key={post.id}>
              {post.id}. {post.title}
            </p>
          ))}
        </React.Fragment>
      ))}

      <button
        onClick={() => fetchNextPage()}
        disabled={!hasNextPage || isFetchingNextPage}
      >
        {isFetchingNextPage ? "Loading more..." : hasNextPage ? "Load More" : "No More Posts"}
      </button>
    </div>
  );
}

export default function App() {
  return (
    <Suspense fallback={<div>Loading posts...</div>}>
      <PostsList />
    </Suspense>
  );
}
```

### Return values

- **data** → The combined paginated data.  
- **fetchNextPage** → Function to fetch the next page.  
- **fetchPreviousPage** → Function to fetch the previous page.  
- **hasNextPage** → Boolean indicating if another page is available.  
- **hasPreviousPage** → Boolean indicating if a previous page exists.  
- **isFetchingNextPage** → Boolean for when the next page is loading.  
- **isFetchingPreviousPage** → Boolean for when the previous page is loading.  

### When to Use

- Infinite scrolling with Suspense boundaries.  
- Automatically combining paginated results.  
- Cleaner loading/error handling with Suspense.  

---

## 14. useSuspenseQueries

- `useSuspenseQueries` is used when you want to **fetch multiple queries in parallel** with React Query Suspense.  
- Unlike `useSuspenseQuery`, it handles an **array of queries** at once.  
- Perfect when you want to load multiple independent resources **before rendering**.

### Example

```tsx
import React, { Suspense } from "react";
import { useSuspenseQueries } from "@tanstack/react-query";
import axios from "axios";

const fetchUser = async (id: number) => {
  const res = await axios.get(`https://jsonplaceholder.typicode.com/users/${id}`);
  return res.data;
};

const fetchPost = async (id: number) => {
  const res = await axios.get(`https://jsonplaceholder.typicode.com/posts/${id}`);
  return res.data;
};

function UserAndPost() {
  const results = useSuspenseQueries({
    queries: [
      {
        queryKey: ["user", 1],
        queryFn: () => fetchUser(1),
      },
      {
        queryKey: ["post", 1],
        queryFn: () => fetchPost(1),
      },
    ],
  });

  const [user, post] = results.map((q) => q.data);

  return (
    <div>
      <h2>User: {user.name}</h2>
      <h3>Post: {post.title}</h3>
    </div>
  );
}

export default function App() {
  return (
    <Suspense fallback={<p>Loading...</p>}>
      <UserAndPost />
    </Suspense>
  );
}
```

---

## 15. useQueryErrorResetBoundary

The `useQueryErrorResetBoundary` hook is a utility in React Query that integrates with **Error Boundaries** to handle query errors gracefully.  
It helps in **resetting error states** and **retrying failed queries** when the user attempts to recover (e.g., via a retry button).  

It’s typically used with **React’s `<ErrorBoundary />`** component.

```ts
const {
  reset,         // function to reset error boundary state
  resetBoundary, // function to be called inside ErrorBoundary fallback
} = useQueryErrorResetBoundary();
```

```tsx
import React from "react";
import { ErrorBoundary } from "react-error-boundary";
import {
  useQuery,
  useQueryErrorResetBoundary,
} from "@tanstack/react-query";

function fetchUser() {
  return fetch("/api/user").then((res) => {
    if (!res.ok) throw new Error("Failed to fetch user");
    return res.json();
  });
}

function User() {
  const { data } = useQuery({
    queryKey: ["user"],
    queryFn: fetchUser,
  });

  return <div>User: {data.name}</div>;
}

function App() {
  const { reset } = useQueryErrorResetBoundary();

  return (
    <ErrorBoundary
      onReset={reset}
      fallbackRender={({ error, resetErrorBoundary }) => (
        <div>
          <p style={{ color: "red" }}>Error: {error.message}</p>
          <button onClick={() => resetErrorBoundary()}>
            Retry
          </button>
        </div>
      )}
    >
      <User />
    </ErrorBoundary>
  );
}
```

---

## 16. QueryErrorResetBoundary

`QueryErrorResetBoundary` is a **React component** provided by React Query that works with error boundaries to handle query errors more gracefully.  
It allows you to reset the error state of queries when retrying or remounting.

### 🔹 Usage

You wrap your components inside `QueryErrorResetBoundary` and use it together with React’s `ErrorBoundary`.  
The reset function provided ensures that failed queries can be retried cleanly without persisting the error state.

### ⚙️ Props

- **children**: A render prop function that receives:
  - `reset` → function to reset query errors.

### 🔄 Common Use Cases

- Handling query failures inside `ErrorBoundary`.
- Allowing retry of failed queries by resetting error state.
- Ensuring queries do not remain stuck in an error state when re-rendered.

### 🔙 Returns

The `children` render function provides:

- **reset** → A function to reset all errors in the query cache.

---

## 17. Hydration Utilities

Hydration utilities in **React Query** are used to support **Server-Side Rendering (SSR)** and **Static Site Generation (SSG)**.  
They allow you to prefetch queries on the server, dehydrate them into a serializable state, and then rehydrate them on the client for seamless hydration.

```tsx
// pages/index.tsx
import { dehydrate, QueryClient, useQuery } from "@tanstack/react-query";
import { Hydrate } from "@tanstack/react-query";
import { QueryClientProvider } from "@tanstack/react-query";

// ✅ Fetch function
const fetchPosts = async () => {
  const res = await fetch("https://jsonplaceholder.typicode.com/posts");
  return res.json();
};

// ✅ Query Hook
function Posts() {
  const { data } = useQuery({
    queryKey: ["posts"],
    queryFn: fetchPosts,
  });

  return (
    <ul>
      {data?.slice(0, 5).map((post: any) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  );
}

// ✅ Page Component
export default function Home({ dehydratedState }: { dehydratedState: unknown }) {
  const queryClient = new QueryClient();

  return (
    <QueryClientProvider client={queryClient}>
      <Hydrate state={dehydratedState}>
        <Posts />
      </Hydrate>
    </QueryClientProvider>
  );
}

// ✅ Next.js Data Fetching (Server)
export async function getServerSideProps() {
  const queryClient = new QueryClient();

  await queryClient.prefetchQuery({
    queryKey: ["posts"],
    queryFn: fetchPosts,
  });

  return {
    props: {
      dehydratedState: dehydrate(queryClient),
    },
  };
}
```

### 🔹 Key Utilities

1. **`dehydrate(client)`**  
   - Extracts the cached queries from the `QueryClient` into a serializable object.  
   - Used on the server (e.g., Next.js `getServerSideProps` or `getStaticProps`).

2. **`Hydrate` component**  
   - Takes the dehydrated state and hydrates it back into React Query’s cache on the client side.

### 🔄 Workflow

1. **Server**: Prefetch queries → `dehydrate` → pass dehydrated state as props.  
2. **Client**: Wrap app in `<Hydrate>` with the dehydrated state → Queries are instantly available without refetch.

### ⚙️ Props for `<Hydrate>`

- **state** → The dehydrated state object.
- **options** → Optional config for hydration behavior (e.g., default stale times).

### 🔙 Common Use Cases

- Next.js, Remix, or any SSR framework.
- Improving performance by avoiding duplicate client-side requests.
- SEO benefits with prefetched data rendered on the server.

---
