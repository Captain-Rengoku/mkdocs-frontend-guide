---
date: 
  created: 2025-08-12
---

# Axios Industry Standards

## Setup â€” axios.create with baseURL

```js
// api.js
import axios from "axios";

const api = axios.create({
  baseURL: "https://api.example.com", // Replace with your API base URL
  timeout: 10000, // optional timeout
  headers: {
    "Content-Type": "application/json",
  },
});

export default api;
```

## GET Methods â€” Without Params

- Use when fetching entire collections without filtering or dynamic params.

```js
// services/dataService.js
import api from "./api";

// 1. Simple GET â€” All users
export const getUsers = async () => {
  try {
    const res = await api.get("/users");
    return res.data;
  } catch (err) {
    console.error("Error fetching users:", err.message);
    throw err;
  }
};

// 2. All posts
export const getPosts = async () => {
  try {
    const { data } = await api.get("/posts");
    return data;
  } catch (error) {
    console.error("Error fetching posts:", error);
    throw error;
  }
};

// 3. All products (inline return)
export const getProducts = async () => {
  try {
    return (await api.get("/products")).data;
  } catch (e) {
    throw new Error(`Products fetch failed: ${e.message}`);
  }
};

// 4. All orders
export const getOrders = async () => {
  try {
    const res = await api.get("/orders");
    return res.data;
  } catch (err) {
    console.error(err);
    throw err;
  }
};

// 5. Generic fetch â€” pass endpoint string
export const getAll = async (endpoint) => {
  try {
    const res = await api.get(`/${endpoint}`);
    return res.data;
  } catch (err) {
    console.error(`Error fetching ${endpoint}:`, err);
    throw err;
  }
};
```

## GET Methods â€” With Params

- Covers Path Params, Query Params, Multiple Params, Conditional Params, and Dynamic Filtering.

### **{++ A. Path Params (REST style)**++}

```js
// Get user by ID
export const getUserById = async (id) => {
  try {
    const res = await api.get(`/users/${id}`);
    return res.data;
  } catch (err) {
    console.error(`Error fetching user ${id}:`, err);
    throw err;
  }
};

// Get post by ID
export const getPostById = async (id) => {
  try {
    return (await api.get(`/posts/${id}`)).data;
  } catch (e) {
    throw e;
  }
};
```

### **{++ B. Query Params (axios params object)**++}

```js
// Get posts by userId
export const getPostsByUser = async (userId) => {
  try {
    const res = await api.get("/posts", { params: { userId } });
    return res.data;
  } catch (err) {
    console.error(err);
    throw err;
  }
};

// Search products by name
export const searchProducts = async (name) => {
  try {
    const res = await api.get("/products", { params: { name } });
    return res.data;
  } catch (err) {
    throw err;
  }
};
```

### **{++ C. Multiple Query Params**++}

```js
// Get orders by userId & status
export const getOrdersByUserAndStatus = async (userId, status) => {
  try {
    const res = await api.get("/orders", {
      params: { userId, status },
    });
    return res.data;
  } catch (err) {
    throw err;
  }
};
```

### **{++ D. Conditional Params (optional filters)**++}

```js
export const getFilteredPosts = async ({ userId, minLikes }) => {
  try {
    const params = {};
    if (userId) params.userId = userId;
    if (minLikes) params.likes_gte = minLikes; // example for JSON-server filtering
    const res = await api.get("/posts", { params });
    return res.data;
  } catch (err) {
    throw err;
  }
};
```

### **{++ E. Array & Complex Params**++}

```js
// Get multiple products by IDs
export const getProductsByIds = async (ids = []) => {
  try {
    const res = await api.get("/products", {
      params: { id: ids }, // axios will serialize as id=1&id=2
    });
    return res.data;
  } catch (err) {
    throw err;
  }
};
```

### **{++ F. Pagination**++}

```js
export const getPaginatedPosts = async (page = 1, limit = 10) => {
  try {
    const res = await api.get("/posts", {
      params: { _page: page, _limit: limit }, // JSON-server pagination
    });
    return res.data;
  } catch (err) {
    throw err;
  }
};
```

### **{++ G. Sorting**++}

```js
export const getSortedProducts = async (sortBy = "price", order = "asc") => {
  try {
    const res = await api.get("/products", {
      params: { _sort: sortBy, _order: order },
    });
    return res.data;
  } catch (err) {
    throw err;
  }
};
```

### **{++ H. Combined: Search + Sort + Pagination**++}

```js
export const searchPosts = async ({
  query,
  sortBy = "likes",
  order = "desc",
  page = 1,
  limit = 5,
}) => {
  try {
    const res = await api.get("/posts", {
      params: {
        q: query,
        _sort: sortBy,
        _order: order,
        _page: page,
        _limit: limit,
      },
    });
    return res.data;
  } catch (err) {
    throw err;
  }
};
```

## POST Methods â€” Without Params

- Used when sending data to create a resource but without dynamic inputs (static payload or predefined object).

```js
// services/dataService.js
import api from "./api";

// 1. Create a sample user (fixed data)
export const createDefaultUser = async () => {
  try {
    const payload = {
      name: "Default User",
      email: "default@example.com",
      age: 25,
      role: "viewer",
    };
    const res = await api.post("/users", payload);
    return res.data;
  } catch (err) {
    console.error("Error creating default user:", err);
    throw err;
  }
};

// 2. Create a default product
export const createDefaultProduct = async () => {
  try {
    const product = {
      name: "Default Product",
      price: 100,
      inStock: true,
    };
    return (await api.post("/products", product)).data;
  } catch (err) {
    throw err;
  }
};
```

## POST Methods â€” With Params

- The params are usually the payload data passed into the function.

### **{++ A. Basic Payload**++}

```js
// Create a new user with dynamic data
export const createUser = async (userData) => {
  try {
    const res = await api.post("/users", userData);
    return res.data;
  } catch (err) {
    console.error("Error creating user:", err);
    throw err;
  }
};

// Create a new post
export const createPost = async ({ userId, title, content, likes = 0 }) => {
  try {
    const res = await api.post("/posts", {
      userId,
      title,
      content,
      likes,
    });
    return res.data;
  } catch (err) {
    throw err;
  }
};
```

### **{++ B. Path Params + Body**++}

- Useful when the resource belongs to another resource (nested routes).

```js
// Create a comment for a specific post
export const createComment = async (postId, { userId, content }) => {
  try {
    const res = await api.post(`/posts/${postId}/comments`, {
      userId,
      content,
    });
    return res.data;
  } catch (err) {
    throw err;
  }
};
```

### **{++ C. Query Params + Body**++}

- Sending additional filtering info via query params.

```js
// Create a product with special flag
export const createProductWithFlag = async (productData, isFeatured) => {
  try {
    const res = await api.post("/products", productData, {
      params: { featured: isFeatured },
    });
    return res.data;
  } catch (err) {
    throw err;
  }
};
```

### **{++ D. Multipart/Form-Data (for file uploads)**++}

- Needed for images, PDFs, etc.

```js
export const uploadProductImage = async (productId, file) => {
  try {
    const formData = new FormData();
    formData.append("image", file);

    const res = await api.post(`/products/${productId}/upload`, formData, {
      headers: { "Content-Type": "multipart/form-data" },
    });
    return res.data;
  } catch (err) {
    throw err;
  }
};
```

### **{++ E. Array of Objects as Payload**++}

```js
// Bulk create products
export const createMultipleProducts = async (products) => {
  try {
    const res = await api.post("/products/bulk", products);
    return res.data;
  } catch (err) {
    throw err;
  }
};
```

### **{++ F. Complex Nested Payload**++}

```js
export const createOrderWithDetails = async ({
  userId,
  items,
  shippingAddress,
  paymentMethod,
}) => {
  try {
    const payload = {
      userId,
      items, // [{ productId, quantity }]
      shippingAddress,
      paymentMethod,
      status: "pending",
    };
    const res = await api.post("/orders", payload);
    return res.data;
  } catch (err) {
    throw err;
  }
};
```

### **{++ G. POST with Default + Override Logic**++}

```js
export const createPostWithDefaults = async (data) => {
  try {
    const defaultPost = {
      likes: 0,
      content: "",
    };
    const payload = { ...defaultPost, ...data }; // Override defaults
    const res = await api.post("/posts", payload);
    return res.data;
  } catch (err) {
    throw err;
  }
};
```

## PUT Methods â€” Without Params

- Static update (rare in production, but possible for test/dummy updates)

```js
// Update a fixed user (id: 1) with static data
export const updateDefaultUser = async () => {
  try {
    const payload = {
      name: "Updated Name",
      email: "updated@example.com",
      age: 30,
      role: "admin",
    };
    const res = await api.put("/users/1", payload);
    return res.data;
  } catch (err) {
    console.error("Error updating default user:", err);
    throw err;
  }
};
```

## PUT Methods â€” With Params

### **{++ A. Path Params + Full Payload**++}

```js
// Update user by ID (replace full object)
export const updateUser = async (id, userData) => {
  try {
    const res = await api.put(`/users/${id}`, userData);
    return res.data;
  } catch (err) {
    console.error(`Error updating user ${id}:`, err);
    throw err;
  }
};

// Update post by ID
export const updatePost = async (id, postData) => {
  try {
    const res = await api.put(`/posts/${id}`, postData);
    return res.data;
  } catch (err) {
    throw err;
  }
};
```

### **{++ B. Query Params + Full Payload**++}

```js
// Update product by passing query instead of path
export const updateProductByQuery = async (productId, productData) => {
  try {
    const res = await api.put(`/products`, productData, {
      params: { id: productId },
    });
    return res.data;
  } catch (err) {
    throw err;
  }
};
```

### **{++ C. Bulk Update with Array Payload**++}

```js
export const bulkUpdateProducts = async (products) => {
  try {
    const res = await api.put("/products/bulk", products);
    return res.data;
  } catch (err) {
    throw err;
  }
};
```

### **{++ D. Nested Resource Update**++}

```js
// Update a comment in a specific post
export const updateComment = async (postId, commentId, commentData) => {
  try {
    const res = await api.put(`/posts/${postId}/comments/${commentId}`, commentData);
    return res.data;
  } catch (err) {
    throw err;
  }
};
```

### **{++ E. Complex Object Update**++}

```js
// Update order with nested shipping & items
export const updateOrderDetails = async (orderId, details) => {
  try {
    const payload = {
      ...details,
      updatedAt: new Date().toISOString(),
    };
    const res = await api.put(`/orders/${orderId}`, payload);
    return res.data;
  } catch (err) {
    throw err;
  }
};
```

### **{++ F. Conditional PUT with Merged Defaults**++}

```js
export const updatePostWithDefaults = async (id, data) => {
  try {
    const defaults = { likes: 0, content: "" };
    const payload = { ...defaults, ...data };
    const res = await api.put(`/posts/${id}`, payload);
    return res.data;
  } catch (err) {
    throw err;
  }
};
```

### **{++ G. PUT with File Upload (Multipart)**++}

```js
export const updateProductImage = async (productId, file) => {
  try {
    const formData = new FormData();
    formData.append("image", file);
    const res = await api.put(`/products/${productId}/upload`, formData, {
      headers: { "Content-Type": "multipart/form-data" },
    });
    return res.data;
  } catch (err) {
    throw err;
  }
};
```

## PATCH â€” Without Params

- Rare, but possible for a static partial update on a fixed resource.

```js
// Update only the role of user with id 1
export const patchDefaultUserRole = async () => {
  try {
    const payload = { role: "editor" };
    const res = await api.patch("/users/1", payload);
    return res.data;
  } catch (err) {
    console.error("Error patching default user role:", err);
    throw err;
  }
};
```

## PATCH â€” With Params

### **{++ A. Path Params + Partial Payload**++}

```js
// Partially update user by ID
export const patchUser = async (id, updates) => {
  try {
    const res = await api.patch(`/users/${id}`, updates);
    return res.data;
  } catch (err) {
    console.error(`Error patching user ${id}:`, err);
    throw err;
  }
};

// Partially update post
export const patchPost = async (id, updates) => {
  try {
    return (await api.patch(`/posts/${id}`, updates)).data;
  } catch (err) {
    throw err;
  }
};
```

### **{++ B. Query Params + Partial Payload**++}

```js
// Update product price using query param
export const patchProductPrice = async (productId, price) => {
  try {
    const res = await api.patch("/products", { price }, { params: { id: productId } });
    return res.data;
  } catch (err) {
    throw err;
  }
};
```

### **{++ C. Bulk Partial Updates**++}

```js
// Update multiple products' prices
export const patchMultipleProducts = async (products) => {
  try {
    const res = await api.patch("/products/bulk", products);
    return res.data;
  } catch (err) {
    throw err;
  }
};
```

### **{++ D. Nested Resource Partial Update**++}

```js
// Update only the content of a comment
export const patchCommentContent = async (postId, commentId, content) => {
  try {
    const res = await api.patch(`/posts/${postId}/comments/${commentId}`, { content });
    return res.data;
  } catch (err) {
    throw err;
  }
};
```

### **{++ E. Conditional Field Updates**++}

```js
// Only send fields that are truthy
export const patchOrderStatus = async (orderId, status, trackingId) => {
  try {
    const payload = {};
    if (status) payload.status = status;
    if (trackingId) payload.trackingId = trackingId;

    const res = await api.patch(`/orders/${orderId}`, payload);
    return res.data;
  } catch (err) {
    throw err;
  }
};
```

### **{++ F. PATCH with Defaults Merge**++}

```js
// Merge defaults and only override specific fields
export const patchPostWithDefaults = async (id, updates) => {
  try {
    const defaults = { likes: 0 };
    const payload = { ...defaults, ...updates };
    const res = await api.patch(`/posts/${id}`, payload);
    return res.data;
  } catch (err) {
    throw err;
  }
};
```

### **{++ G. PATCH with Multipart/Form-Data**++}

```js
export const patchProductImage = async (productId, file) => {
  try {
    const formData = new FormData();
    formData.append("image", file);

    const res = await api.patch(`/products/${productId}/upload`, formData, {
      headers: { "Content-Type": "multipart/form-data" },
    });
    return res.data;
  } catch (err) {
    throw err;
  }
};
```

## DELETE â€” Without Params

- Rare in production, but could be used for clearing all data in a resource (admin-level operation).

```js
// Delete ALL posts (dangerous)
export const deleteAllPosts = async () => {
  try {
    const res = await api.delete("/posts");
    return res.data;
  } catch (err) {
    console.error("Error deleting all posts:", err);
    throw err;
  }
};
```

## DELETE â€” With Params

### **{++ A. Path Params**++}

```js
// Delete user by ID
export const deleteUser = async (id) => {
  try {
    const res = await api.delete(`/users/${id}`);
    return res.data;
  } catch (err) {
    console.error(`Error deleting user ${id}:`, err);
    throw err;
  }
};

// Delete post by ID
export const deletePost = async (id) => {
  try {
    return (await api.delete(`/posts/${id}`)).data;
  } catch (err) {
    throw err;
  }
};
```

### **{++ B. Query Params**++}

```js
// Delete product by passing query param
export const deleteProductByQuery = async (productId) => {
  try {
    const res = await api.delete("/products", { params: { id: productId } });
    return res.data;
  } catch (err) {
    throw err;
  }
};
```

### **{++ C. Bulk Delete via Array Payload**++}

```js
// Delete multiple products at once
export const bulkDeleteProducts = async (ids) => {
  try {
    const res = await api.delete("/products/bulk", {
      data: { ids }, // axios DELETE supports "data" for payload
    });
    return res.data;
  } catch (err) {
    throw err;
  }
};
```

### **{++ D. Nested Resource Delete**++}

```js
// Delete a comment from a post
export const deleteComment = async (postId, commentId) => {
  try {
    const res = await api.delete(`/posts/${postId}/comments/${commentId}`);
    return res.data;
  } catch (err) {
    throw err;
  }
};
```

### **{++ E. Conditional Delete with Filters**++}

```js
// Delete orders by status
export const deleteOrdersByStatus = async (status) => {
  try {
    const res = await api.delete("/orders", { params: { status } });
    return res.data;
  } catch (err) {
    throw err;
  }
};
```

### **{++ F. Authenticated Delete (with token)**++}

```js
// Delete product with authorization
export const deleteProductWithAuth = async (productId, token) => {
  try {
    const res = await api.delete(`/products/${productId}`, {
      headers: { Authorization: `Bearer ${token}` },
    });
    return res.data;
  } catch (err) {
    throw err;
  }
};
```

### **{++ G. Soft Delete (Mark as Deleted Instead of Removing)**++}

```js
// Soft delete a post by patching a deleted flag
export const softDeletePost = async (postId) => {
  try {
    const res = await api.patch(`/posts/${postId}`, { deleted: true });
    return res.data;
  } catch (err) {
    throw err;
  }
};
```

## Advanced & Complex API usage patterns

### 1ï¸âƒ£ Axios Request Cancellation (AbortController)

- Avoids race conditions when multiple requests are fired rapidly (e.g., live search).

```js
let controller;

export const searchPostsLive = async (query) => {
  if (controller) controller.abort(); // cancel previous request
  controller = new AbortController();

  try {
    const res = await api.get("/posts", {
      params: { q: query },
      signal: controller.signal,
    });
    return res.data;
  } catch (err) {
    if (err.name === "CanceledError") {
      console.log("Request canceled");
    } else {
      throw err;
    }
  }
};
```

### 2ï¸âƒ£ Axios Interceptors (Auth, Logging, Error Handling)

- Global handling for tokens, logs, and error transformations.

```js
api.interceptors.request.use((config) => {
  const token = localStorage.getItem("token");
  if (token) config.headers.Authorization = `Bearer ${token}`;
  return config;
});

api.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401) {
      console.warn("Unauthorized, redirecting to login...");
    }
    return Promise.reject(error);
  }
);
```

### 3ï¸âƒ£ Parallel API Calls (Promise.all)

- Fetch multiple resources at once for better performance.

```js
export const getDashboardData = async () => {
  try {
    const [users, posts, products] = await Promise.all([
      api.get("/users"),
      api.get("/posts"),
      api.get("/products"),
    ]);

    return {
      users: users.data,
      posts: posts.data,
      products: products.data,
    };
  } catch (err) {
    throw err;
  }
};
```

### 4ï¸âƒ£ Dependent (Sequential) Requests

- Where the second request depends on the first requestâ€™s data.

```js
export const getUserWithPosts = async (userId) => {
  try {
    const user = await api.get(`/users/${userId}`);
    const posts = await api.get("/posts", { params: { userId } });
    return { ...user.data, posts: posts.data };
  } catch (err) {
    throw err;
  }
};
```

### 5ï¸âƒ£ Retry Failed Requests with Exponential Backoff

- Handles flaky network/API failures.

```js
export const fetchWithRetry = async (endpoint, retries = 3, delay = 1000) => {
  try {
    const res = await api.get(endpoint);
    return res.data;
  } catch (err) {
    if (retries > 0) {
      await new Promise((resolve) => setTimeout(resolve, delay));
      return fetchWithRetry(endpoint, retries - 1, delay * 2); // exponential backoff
    }
    throw err;
  }
};
```

### 6ï¸âƒ£ Request Timeouts

- Abort request if it takes too long.

```js
export const getFastResponse = async () => {
  try {
    const res = await api.get("/products", { timeout: 3000 });
    return res.data;
  } catch (err) {
    if (err.code === "ECONNABORTED") {
      console.warn("Request timed out");
    }
    throw err;
  }
};
```

### 7ï¸âƒ£ Pagination & Infinite Scroll Loader

- Advanced API with stateful pagination.

```js
export const getPaginatedUsers = async (page, limit = 10) => {
  try {
    const res = await api.get("/users", { params: { _page: page, _limit: limit } });
    return {
      data: res.data,
      totalCount: parseInt(res.headers["x-total-count"], 10) || 0,
    };
  } catch (err) {
    throw err;
  }
};
```

### 8ï¸âƒ£ Batch Request Processing

- Send multiple related changes in one API call.

```js
export const batchUpdateOrders = async (updates) => {
  try {
    return (await api.patch("/orders/batch", updates)).data;
  } catch (err) {
    throw err;
  }
};
```

### 9ï¸âƒ£ File Upload with Progress Tracking

- Common for dashboards and CMS systems.

```js
export const uploadFileWithProgress = async (file, onProgress) => {
  try {
    const formData = new FormData();
    formData.append("file", file);

    const res = await api.post("/upload", formData, {
      headers: { "Content-Type": "multipart/form-data" },
      onUploadProgress: (progressEvent) => {
        const percent = Math.round((progressEvent.loaded * 100) / progressEvent.total);
        onProgress(percent);
      },
    });
    return res.data;
  } catch (err) {
    throw err;
  }

};
```

### ðŸ”Ÿ Optimistic UI Updates

- Update UI instantly before API confirmation.

```js
export const likePostOptimistic = async (postId, currentLikes, setLikes) => {
  // Instantly update UI
  setLikes(currentLikes + 1);

  try {
    await api.patch(`/posts/${postId}`, { likes: currentLikes + 1 });
  } catch (err) {
    // Revert if failed
    setLikes(currentLikes);
    throw err;
  }
};
```

### 1ï¸âƒ£1ï¸âƒ£ Cache + LocalStorage Fallback

- Reduces API calls by caching results.

```js
export const getCachedUsers = async () => {
  const cache = localStorage.getItem("usersCache");
  if (cache) return JSON.parse(cache);

  const res = await api.get("/users");
  localStorage.setItem("usersCache", JSON.stringify(res.data));
  return res.data;
};
```

### 1ï¸âƒ£2ï¸âƒ£ Axios Instance per Feature

- Multiple axios.create instances for microservice APIs.

```js
export const authApi = axios.create({ baseURL: "https://auth.example.com" });
export const productApi = axios.create({ baseURL: "https://products.example.com" });
```

## API Folder Structure

### React (Vite / CRA)

```txt
src/
â”‚
â”œâ”€â”€ api/                     # Central place for axios instances & API calls
â”‚   â”œâ”€â”€ axiosClient.js       # axios.create base instance
â”‚   â”œâ”€â”€ users.api.js         # User-related API calls
â”‚   â”œâ”€â”€ posts.api.js         # Post-related API calls
â”‚   â”œâ”€â”€ comments.api.js      # Comment-related API calls
â”‚   â”œâ”€â”€ products.api.js      # Product-related API calls
â”‚   â”œâ”€â”€ orders.api.js        # Order-related API calls
â”‚   â””â”€â”€ index.js             # Export all APIs from one place
â”‚
â”œâ”€â”€ services/                # Optional: business logic using API calls
â”‚   â””â”€â”€ order.service.js
â”‚
â”œâ”€â”€ components/
â”‚   â””â”€â”€ ...
â”‚
â”œâ”€â”€ pages/                   # Page-level components (if not using Next.js)
â”‚   â””â”€â”€ ...
â”‚
â””â”€â”€ App.jsx
```

- axiosClient.js holds your baseURL, interceptors, and defaults.

```js
// src/api/axiosClient.js
import axios from 'axios';

const axiosClient = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_BASE_URL || 'https://api.example.com',
  headers: {
    'Content-Type': 'application/json',
  },
  withCredentials: true, // if needed for cookies/auth
});

// Request interceptor
axiosClient.interceptors.request.use(
  (config) => {
    // Example: attach token
    const token = localStorage.getItem('accessToken');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => Promise.reject(error)
);

// Response interceptor
axiosClient.interceptors.response.use(
  (response) => response.data,
  (error) => {
    console.error('API Error:', error);
    return Promise.reject(error);
  }
);

export default axiosClient;
```

- Each *.api.js file contains only functions that call APIs.

```js
// src/api/users.api.js
import axiosClient from './axiosClient';

export const getAllUsers = () => axiosClient.get('/users');
export const getUserById = (id) => axiosClient.get(`/users/${id}`);
export const createUser = (data) => axiosClient.post('/users', data);
export const updateUser = (id, data) => axiosClient.put(`/users/${id}`, data);
export const deleteUser = (id) => axiosClient.delete(`/users/${id}`);
```

```js
// src/api/posts.api.js
import axiosClient from './axiosClient';

export const getAllPosts = () => axiosClient.get('/posts');
export const getPostById = (id) => axiosClient.get(`/posts/${id}`);
export const createPost = (data) => axiosClient.post('/posts', data);
export const updatePost = (id, data) => axiosClient.put(`/posts/${id}`, data);
export const deletePost = (id) => axiosClient.delete(`/posts/${id}`);
```

- index.js for export them from one file

```js
// src/api/index.js
import * as UsersAPI from './users.api';
import * as PostsAPI from './posts.api';
import * as CommentsAPI from './comments.api';
import * as ProductsAPI from './products.api';
import * as OrdersAPI from './orders.api';

export {
  UsersAPI,
  PostsAPI,
  CommentsAPI,
  ProductsAPI,
  OrdersAPI
};
```

- services/ layer is optional â€” use it if you want to combine multiple API calls or apply business logic before sending to UI.

```js
// src/services/user.service.js
import { getUser, createUser } from "../api/users.api";

export const registerAndFetchUser = async (userData) => {
  const newUser = await createUser(userData);
  return await getUser(newUser.data.id);
};
```

### Next.js (App Router / Pages Router)

Frontend API calls

```txt
src/
â”‚
â”œâ”€â”€ lib/                     # Shared utilities
â”‚   â””â”€â”€ axiosClient.js       # axios.create base instance
â”‚
â”œâ”€â”€ api/                     # API call functions
â”‚   â”œâ”€â”€ users.api.js
â”‚   â”œâ”€â”€ posts.api.js
â”‚   â”œâ”€â”€ comments.api.js
â”‚   â”œâ”€â”€ products.api.js
â”‚   â”œâ”€â”€ orders.api.js
â”‚   â””â”€â”€ index.js
â”‚
â”œâ”€â”€ app/                     # App Router structure
â”‚   â”œâ”€â”€ page.jsx
â”‚   â””â”€â”€ dashboard/
â”‚       â””â”€â”€ page.jsx
â”‚
â””â”€â”€ components/
```
