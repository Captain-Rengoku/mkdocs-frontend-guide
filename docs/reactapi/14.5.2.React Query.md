---
date: 
  created: 2025-08-12
---

# React Query Comprehensive Topics

## 0Ô∏è‚É£ Introduction

### Problem Statement

- Since React is a UI library, there is no specific pattern for data fetching
- We typically use the useEffect hook for data fetching and useState hook to maintain component state like loading, error state or the resulting data
- If the data is needed throughout the app, then we tend to use state management libraries like Redux
- Most of the state management libraries are good for working with client state. Ex. 'theme' for an application / whether a modal is open
- State Management Libraries are not great for working with asynchronous or server state

#### Client vs server state

- **Client state:**
  - Persisted in your app memory and accessing or updating it is synchronous

- **Server state:**
  - Persisted remotely and requires asynchronous APIs for fetching or updating
  - Has shared ownership
  - Data can be updated by someone else without your knowledge
  - UI data may not be in sync with the remote server/database data
  - Challenging when you have to deal with caching, deduplication of multiple requests for thsame data, updating stale data in the background, performance optimizations in pagination and lazy-loading, etc

### What is React Query?

- React Query is a powerful data-fetching and state management library for React applications.
- It provides a set of hooks for fetching, caching, synchronizing, and updating server state in your UI, without needing complex global state management solutions like Redux.

Created by Tanner Linsley, React Query simplifies remote data management by:

- Automatically caching fetched data
- Keeping data fresh via background refetching
- Avoiding duplicate network requests
- Simplifying pagination, infinite scrolling, and optimistic updates

### Why Use React Query?

Traditionally, managing server state involved juggling global stores (Redux, MobX), side effects (Redux-Thunk, Redux-Saga), and manual caching logic. React Query eliminates this complexity by abstracting most of this away, offering:

- ‚úÖ **Auto caching and background syncing**
- üîÅ **Refetch on focus or reconnect**
- üí° **Stale-while-revalidate logic**
- üöÄ **Performance optimization out of the box**
- üîÑ **Support for paginated and infinite queries**
- üí• **Built-in retry and error recovery**
- üîß **DevTools for debugging query states**

React Query is especially useful in apps with a lot of asynchronous data (like dashboards, admin panels, and data-heavy UIs).

### Core Concepts Overview

Here are the fundamental building blocks of React Query:

- **Query (useQuery)**: Used to fetch and cache server data. Handles loading, error, and success states.
- **Mutation (useMutation)**: Used to send data to the server (e.g., POST, PUT, DELETE). Supports optimistic updates.
- **Query Keys**: Unique identifiers for queries; essential for caching and invalidation.
- **Query Client**: A central manager for all queries/mutations. Configures global settings like retry count and cache time.
- **DevTools**: Visual debugging tool to inspect the query cache, query states, and performance.

### Comparison with Redux & SWR

| Feature                | React Query          | Redux                          | SWR                       |
|------------------------|----------------------|--------------------------------|----------------------------|
| Purpose               | Server state mgmt     | Global app & server state mgmt | Server state mgmt         |
| Data Caching          | ‚úÖ Built-in           | ‚ùå Manual                      | ‚úÖ Built-in               |
| Background Refetching | ‚úÖ Yes                | ‚ùå No                          | ‚úÖ Yes                    |
| DevTools              | ‚úÖ Yes                | ‚úÖ (via Redux DevTools)       | ‚ùå No (community-based)   |
| Boilerplate           | Minimal               | High                           | Minimal                   |
| Optimistic Updates    | ‚úÖ Yes                | ‚ùå Manual                      | üöß Limited                |
| Pagination Support    | ‚úÖ Yes                | ‚ùå Manual                      | üöß Basic support          |
| Learning Curve        | Medium                | High                           | Low                       |

**Summary**:  
React Query is ideal when your app heavily interacts with remote data and you want to avoid over-engineering with global state libraries like Redux. It's more full-featured than SWR and offers deep control and performance optimizations for serious production use.

### React Query - Setup

#### 1. Install Dependencies

Go to react query docs for installation
-- <https://tanstack.com/query/latest/docs/framework/react/installation>

```bash
# Install React Query
npm install @tanstack/react-query

# Optional: React Query Devtools
npm install @tanstack/react-query-devtools
```

also install react-router for routing in React

```bash
npm install react-router
```

#### 2. Set Up Query Client

Create a `QueryClient` and wrap your app with `QueryClientProvider` in `main.jsx`.

```js
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { ReactQueryDevtools } from "@tanstack/react-query-devtools";

// Create a client
const queryClient = new QueryClient();

ReactDOM.createRoot(document.getElementById("root")).render(
  <React.StrictMode>
    <QueryClientProvider client={queryClient}>
      <App />
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  </React.StrictMode>
);
```

#### 3. Create a Fetcher Function

Define a function that fetches data from your API. You can use `fetch` or `axios`.

```js
// api/posts.js
export const fetchPosts = async () => {
  const response = await fetch("https://jsonplaceholder.typicode.com/posts");
  if (!response.ok) {
    throw new Error("Network response was not ok");
  }
  return response.json();
};
```

```js
// api/posts.js
import axios from "axios";
export const fetchPosts = async () => {
  try {
    const response = await axios.get("https://jsonplaceholder.typicode.com/posts");
    return response.data;
  } catch (error) {
    throw new Error(error.response?.statusText || "Network request failed");
  }
};
```

#### 4. Use React Query in a Component

Use `useQuery` to fetch data and handle loading, error, and success states automatically.

```js
import { useQuery } from "@tanstack/react-query";
import { fetchPosts } from "./api/posts";

export default function PostsList() {
  const { data, isLoading, isError, error } = useQuery({
    // the path becomes the queryKey here,
      // /posts --> ["posts"]
      // /posts/1 --> ["posts", 1]
      // /posts/2 --> ["posts", 2]
      // or for dynamic route
      // /posts/:id --> ["posts", post.id]
      // /posts/:id/comments --> ["posts", post.id, "comments"]
    queryKey: ["posts"],
    // the queryFn is a Callback Function that returns a promise
    queryFn: fetchPosts,
  });

  if (isLoading) return <p>Loading...</p>;
  if (isError) return <p>Error: {error.message}</p>;

  return (
    <ul>
      {data.map((post) => (
        <li key={post.id}>
          <h3>{post.title}</h3>
          <p>{post.body}</p>
        </li>
      ))}
    </ul>
  );
}
```

#### 5. Key Concepts

- **queryKey** ‚Üí Unique key for caching and refetching.
- **queryFn** ‚Üí Function returning a promise (fetcher).
- **Automatic caching** ‚Üí Data is cached and updated automatically.
- **Stale time & refetch** ‚Üí Configurable to control updates.
- **Devtools** ‚Üí Visualize query cache and state in the browser.

---

## 1Ô∏è‚É£ Core Concepts

### **QueryClient**  

- **Purpose:** Central object that manages queries, mutations, cache, and default configurations.  
- **Key Options:**
      - `staleTime` ‚Äì The time during which cached data is considered fresh. While data is ‚Äúfresh,‚Äù React Query will not automatically refetch it when a component mounts or window refocuses.
      - `cacheTime` ‚ÄìThe time after which unused (inactive) cached data is garbage-collected. ‚ÄúUnused‚Äù means no active queries or components are currently subscribing to it.
      - `refetchOnWindowFocus` ‚Äì Refetch queries when window regains focus.  

- **Example:**

```js
// src/main.jsx
import { QueryClient } from "@tanstack/react-query";

const queryClient = new QueryClient({
  // Default options: `staleTime`, `cacheTime`, `refetchOnWindowFocus`.
  // here we are just create a QueryClient with Default Options
  defaultOptions: {
    queries: {
      // Configure how long the data should remain fresh, or won't turn into stale value.
      // Default staleTime = 0 ms
      // lets keep the value fresh for one minute
      staleTime: 1000 * 60, // 1 minute

      //The default value of cacheTime in React Query is: 5 minutes (1000 * 60 * 5 ms)
      cacheTime: 1000 * 60 * 5, // 5 minutes

      // Fires when the browser window/tab regains focus. 
      // When the user switches to another tab or window and comes back, React Query will refetch queries that are stale.
      // This ensures the UI shows the most up-to-date data without the user needing to refresh manually.
      refetchOnWindowFocus: true,   // default, refetch when window refocuses
      // refetchOnWindowFocus: false  // never refetch automatically on focus
      // refetchOnWindowFocus: 'always' // always refetch even if data is fresh

      // Fires when a component mounts that uses the query.
      // On component mount, React Query decides whether to refetch based on the staleness of the data.
      // refetchOnMount: true        // Refetch if the data is stale
      // refetchOnMount: false       // Never refetch on mount
      refetchOnMount: 'always'    // default, Always refetch, even if data is fresh
      // Useful when you want to ensure the component always shows up-to-date data on mount.
      // Can be set to false if you trust the cached data and want instant UI without unnecessary network requests.
    },
  },
});
```

- staleTime = 1 min
      - During this time, data is ‚Äúfresh.‚Äù
      - React Query will never show a loading state if a component mounts ‚Äî it just serves the cached data.

- After 1 min ‚Üí data becomes stale
      - React Query considers it stale and can refetch it in the background if refetchOnMount or refetchOnWindowFocus is enabled.
      - But the cached data is still available, so the UI can display stale data immediately instead of showing Loading....

- cacheTime = 5 min
      - Even if no component is using the query, React Query keeps the data in memory for 5 minutes.
      - If a component mounts within that 5 minutes, it gets stale data immediately while the background refetch happens.
      - Only after 5 minutes of inactivity is the cache removed ‚Äî then a new fetch will show Loading....

#### React Query: Options

- **queryKey**  
      - Unique key identifying the query in the cache.  
      - Can be a string or array (for dynamic keys).  

- **queryFn**  
      - Function that fetches the data.  
      - Must return a promise.  

- **staleTime**  
      - Time (ms) that data is considered "fresh."  
      - Default: 0 (data is stale immediately).  

- **cacheTime**  
      - Time (ms) that unused data stays in memory before garbage collection.  
      - Default: 5 minutes.  

- **enabled**  
      - Boolean to enable/disable the query.  
      - Useful for conditional queries.  

- **refetchOnMount**  
      - Controls whether to refetch when the component mounts.  
      - Options: `true | false | 'always'`.  

- **refetchOnWindowFocus**  
      - Controls whether to refetch when the browser window gains focus.  
      - Options: `true | false | 'always'`.  

- **refetchOnReconnect**  
      - Refetch when the network reconnects.  
      - Options: `true | false | 'always'`.  

- **retry**  
      - Number of retry attempts if the query fails.  
      - Can be a number or a function returning a boolean.  
      - Default: 3.  

- **retryDelay**  
      - Delay (ms) between retry attempts.  
      - Can be a number or a function.  

- **onSuccess**  
      - Callback fired when the query succeeds.  

- **onError**  
      - Callback fired when the query fails.  

- **onSettled**  
      - Callback fired when the query finishes, regardless of success or error.  

- **select**  
      - Transform or map the fetched data before returning it.  

- **initialData**  
      - Provides default data before the query resolves.  

- **placeholderData**  
      - Data to display while the query is loading.  

- **keepPreviousData**  
      - Keeps previous query data while fetching new data (useful for pagination).  

- **structuralSharing**  
      - Controls how updates to data affect reference equality (default: shallow).  

- **refetchInterval**  
      - Automatically refetch the query every X ms.  
      - Can be a number or `false` to disable.  

- **refetchIntervalInBackground**  
      - If true, refetch interval continues even when the window is not focused.  

- **onSettled**  
      - Callback that runs after the query completes (success or error).  

### **QueryClientProvider**

- Purpose: Wrap your app to provide the QueryClient instance globally.
- Example:

```js
import { QueryClientProvider } from "@tanstack/react-query";
import { ReactQueryDevtools } from "@tanstack/react-query-devtools";

// Create a Client
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      // every defalut query you want to give goes here.
    }
  }
});

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <MyAppComponents />
      {/* if you want to use react query devtools */}
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  );
}
```

### **useQuery**

- Purpose: Fetch and cache data from an API. Handles loading, error, and success automatically.
- Key Options:
      - `queryKey` ‚Äì Unique cache key.
      - `queryFn` ‚Äì Function returning a promise.
      - `enabled` ‚Äì Conditionally run the query.
      - `staleTime` ‚Äì How long data stays fresh.
      - `refetchInterval` ‚Äì Polling interval.
      - `retry` ‚Äì Number of retry attempts on failure.
- Example:

```js
import { useQuery } from "@tanstack/react-query";

const fetchUsers = async () => {
  const res = await fetch("https://jsonplaceholder.typicode.com/users");
  if (!res.ok) throw new Error("Failed to fetch users");
  return res.json();
};

export default function UsersList() {
  const { data, isLoading, isError, error } = useQuery({
    queryKey: ["users"],
    queryFn: fetchUsers,
    staleTime: 1000 * 60, // 1 min
    retry: 2,
  });

  if (isLoading) return <p>Loading...</p>;
  if (isError) return <p>Error: {error.message}</p>;

  return (
    <ul>
      {data.map(user => <li key={user.id}>{user.name}</li>)}
    </ul>
  );
}
```

#### React Query Object Props

- **data**
      - The resolved data from the query function.
      - `undefined` if data hasn‚Äôt been fetched yet.

- **error**
      - The error object if the query fails.
      - `null` if no error.

- **isLoading**
      - `true` while the query is in its initial loading state.
      - Only true on the first fetch.

- **isFetching**
      - `true` whenever the query is fetching data (initial or background refetch).
      - Useful to show loading indicators even on background updates.

- **isError**
      - `true` if the query has encountered an error.

- **isSuccess**
      - `true` if the query successfully fetched data.

- **isIdle**
      - `true` if the query is disabled (`enabled: false`) and hasn‚Äôt run yet.

- **refetch**
      - Function to manually refetch the query.

- **status**
      - Overall status of the query: `"idle" | "loading" | "error" | "success"`.

- **failureCount**
      - Number of times the query has failed.

- **isFetched**
      - `true` if the query has been fetched at least once, regardless of success or error.

- **isFetchedAfterMount**
      - `true` if the query has been fetched after the component mounted.

- **dataUpdatedAt**
      - Timestamp (ms) when the data was last updated.

- **errorUpdatedAt**
      - Timestamp (ms) when the error was last updated.

- **remove**
      - Function to manually remove the query from the cache.

- **refetchOnWindowFocus**
      - Boolean indicating if the query will refetch when the window regains focus (from options).

- **refetchOnReconnect**
      - Boolean indicating if the query will refetch when network reconnects.

- **isStale**
      - Boolean indicating whether the data is stale according to `staleTime`.

- **isPlaceholderData**
      - Boolean indicating whether the query is using placeholder data.

- **isPreviousData**
      - Boolean indicating whether the data is from a previous query while fetching new data.

### **useMutation**

- Purpose: Perform POST, PUT, PATCH, DELETE operations with automatic cache updates.
- Key Options:
      - `onSuccess` ‚Äì Called after successful mutation.
      - `onError` ‚Äì Called if mutation fails.
      - `onSettled` ‚Äì Called after either success or error.
- Example:

```js
import { useMutation, useQueryClient } from "@tanstack/react-query";

const addUser = async (user) => {
  const res = await fetch("https://jsonplaceholder.typicode.com/users", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(user),
  });
  if (!res.ok) throw new Error("Failed to add user");
  return res.json();
};

export default function AddUserForm() {
  const queryClient = useQueryClient();
  const mutation = useMutation(addUser, {
    onSuccess: () => {
      // Invalidate and refetch users query
      queryClient.invalidateQueries(["users"]);
    },
    onError: (error) => console.error("Error:", error),
  });

  const handleSubmit = (e) => {
    e.preventDefault();
    const user = { name: "John Doe" };
    mutation.mutate(user);
  };

  return <button onClick={handleSubmit}>Add User</button>;
}
```

### **useQueryClient**

- Purpose: Access and manipulate the query cache manually.
- Common Use Cases:
      - Invalidate queries
      - Prefetch queries
      - Update cached data optimistically
- Example:

```js
import { useQueryClient } from "@tanstack/react-query";

const queryClient = useQueryClient();
// refetch users
queryClient.invalidateQueries(["users"]); 
// optimistic update
queryClient.setQueryData(["users"], oldData => [...oldData, newUser]); 
```

---

## 2Ô∏è‚É£ Query Keys and Cache

- **Query Keys**
      - Unique identifiers for each query.
      - Simple (string) vs. complex (arrays, objects) keys.
- **Cache Management**
      - Invalidation: `queryClient.invalidateQueries`.
      - Refetching: `queryClient.refetchQueries`.
      - Prefetching: `queryClient.prefetchQuery`.
      - Manual cache updates: `queryClient.setQueryData`, `queryClient.getQueryData`.

---

## 3Ô∏è‚É£ Fetching Patterns

- **Basic GET requests**
- **Dependent Queries**
      - Fetch query B after query A succeeds.
- **Paginated Queries**
      - Page-based fetching with `useQuery`.
- **Infinite Queries**
      - Cursor-based infinite scrolling using `useInfiniteQuery`.
- **Conditional Queries**
      - `enabled` option to control execution.

---

## 4Ô∏è‚É£ Mutations

- **Basic Mutation**
      - Create, update, or delete data.
- **Optimistic Updates**
      - Update UI before mutation is confirmed.
- **Error Handling**
      - Rollback updates on failure.
- **Invalidate Queries**
      - Automatically refresh related queries after mutation.

---

## 5Ô∏è‚É£ Query Lifecycle & Refetching

- **Stale vs Fresh Data**
- **Refetch on window focus**
- **Refetch on reconnect**
- **Polling / Interval Refetching**
- **Suspense Mode**
      - Use with React Suspense for declarative loading states.

---

## 6Ô∏è‚É£ Error Handling

- Global error handling via `QueryClient`.
- Per-query error handling using `onError`.
- Retry logic and exponential backoff.

---

## 7Ô∏è‚É£ DevTools

- **React Query Devtools**
      - Inspect cache, queries, mutations, and state.
      - Configure initial open/close state.

---

## 8Ô∏è‚É£ Advanced Features

- **Query Cancellation**
      - Cancel in-flight queries when component unmounts.
- **Background Fetching**
      - Refresh data silently.
- **Infinite Scrolling**
      - Load more data dynamically as user scrolls.
- **Prefetching**
      - Preload data before user navigates.

---

## 9Ô∏è‚É£ Integration with Axios / Fetch

- Use Axios or Fetch as query functions.
- Handle headers, auth tokens, interceptors if needed.

---

## üîü Best Practices

- Keep query functions pure (no side-effects).
- Use unique query keys.
- Group related queries logically.
- Avoid unnecessary re-renders by memoizing components.
- Leverage `staleTime` and `cacheTime` for performance.
- Combine with global state management when needed (optional).

---

This roadmap covers **everything from basic fetching to advanced caching, mutations, pagination, optimistic updates, background updates, and best practices**. Following this will make you **job-ready in React Query for frontend API integration**.
