---
date: 
  created: 2025-08-12
---

# React Query Comprehensive Topics

## 0Ô∏è‚É£ Introduction

### Problem Statement

- Since React is a UI library, there is no specific pattern for data fetching
- We typically use the useEffect hook for data fetching and useState hook to maintain component state like loading, error state or the resulting data
- If the data is needed throughout the app, then we tend to use state management libraries like Redux
- Most of the state management libraries are good for working with client state. Ex. 'theme' for an application / whether a modal is open
- State Management Libraries are not great for working with asynchronous or server state

#### Client vs server state

- **Client state:**
  - Persisted in your app memory and accessing or updating it is synchronous

- **Server state:**
  - Persisted remotely and requires asynchronous APIs for fetching or updating
  - Has shared ownership
  - Data can be updated by someone else without your knowledge
  - UI data may not be in sync with the remote server/database data
  - Challenging when you have to deal with caching, deduplication of multiple requests for thsame data, updating stale data in the background, performance optimizations in pagination and lazy-loading, etc

### What is React Query?

- React Query is a powerful data-fetching and state management library for React applications.
- It provides a set of hooks for fetching, caching, synchronizing, and updating server state in your UI, without needing complex global state management solutions like Redux.

Created by Tanner Linsley, React Query simplifies remote data management by:

- Automatically caching fetched data
- Keeping data fresh via background refetching
- Avoiding duplicate network requests
- Simplifying pagination, infinite scrolling, and optimistic updates

### Why Use React Query?

Traditionally, managing server state involved juggling global stores (Redux, MobX), side effects (Redux-Thunk, Redux-Saga), and manual caching logic. React Query eliminates this complexity by abstracting most of this away, offering:

- ‚úÖ **Auto caching and background syncing**
- üîÅ **Refetch on focus or reconnect**
- üí° **Stale-while-revalidate logic**
- üöÄ **Performance optimization out of the box**
- üîÑ **Support for paginated and infinite queries**
- üí• **Built-in retry and error recovery**
- üîß **DevTools for debugging query states**

React Query is especially useful in apps with a lot of asynchronous data (like dashboards, admin panels, and data-heavy UIs).

### Core Concepts Overview

Here are the fundamental building blocks of React Query:

- **Query (useQuery)**: Used to fetch and cache server data. Handles loading, error, and success states.
- **Declarative Data Fetching**: React Query promotes a declarative approach to data fetching. You define queries and mutations using hooks like `useQuery` and `useMutation`. This leads to cleaner and more organized code.
- **Mutation (useMutation)**: Used to send data to the server (e.g., POST, PUT, DELETE). Supports optimistic updates.
- **Query Keys**: Unique identifiers for queries; essential for caching and invalidation.
- **Query Client**: A central manager for all queries/mutations. Configures global settings like retry count and cache time.
- **Automatic Caching**: React Query includes a built-in cache that stores query results. It automatically updates data when mutations occur, ensuring your UI remains consistent.
- **Background Data Sync**: It can automatically refetch data in the background, keeping your data fresh without manual intervention.
- **Pagination and Infinite Scrolling**: React Query provides utilities for handling pagination and infinite scrolling effortlessly.
- **Optimistic Updates**: You can implement optimistic updates with ease, making your app feel more responsive.
- **DevTools**: Visual debugging tool to inspect the query cache, query states, and performance.

### Comparison with Redux & SWR

| Feature                | React Query          | Redux                          | SWR                       |
|------------------------|----------------------|--------------------------------|----------------------------|
| Purpose               | Server state mgmt     | Global app & server state mgmt | Server state mgmt         |
| Data Caching          | ‚úÖ Built-in           | ‚ùå Manual                      | ‚úÖ Built-in               |
| Background Refetching | ‚úÖ Yes                | ‚ùå No                          | ‚úÖ Yes                    |
| DevTools              | ‚úÖ Yes                | ‚úÖ (via Redux DevTools)       | ‚ùå No (community-based)   |
| Boilerplate           | Minimal               | High                           | Minimal                   |
| Optimistic Updates    | ‚úÖ Yes                | ‚ùå Manual                      | üöß Limited                |
| Pagination Support    | ‚úÖ Yes                | ‚ùå Manual                      | üöß Basic support          |
| Learning Curve        | Medium                | High                           | Low                       |

**Summary**:  
React Query is ideal when your app heavily interacts with remote data and you want to avoid over-engineering with global state libraries like Redux. It's more full-featured than SWR and offers deep control and performance optimizations for serious production use.

### React Query - Setup

#### 1. Install Dependencies

Go to react query docs for installation
-- <https://tanstack.com/query/latest/docs/framework/react/installation>

```bash
# Install React Query
npm install @tanstack/react-query

# Optional: React Query Devtools
npm install @tanstack/react-query-devtools
```

also install react-router for routing in React

```bash
npm install react-router
```

#### 2. Set Up Query Client

Create a `QueryClient` and wrap your app with `QueryClientProvider` in `main.jsx`.

```js
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { ReactQueryDevtools } from "@tanstack/react-query-devtools";

// Create a client
const queryClient = new QueryClient();

ReactDOM.createRoot(document.getElementById("root")).render(
  <React.StrictMode>
    <QueryClientProvider client={queryClient}>
      <App />
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  </React.StrictMode>
);
```

#### 3. Create a Fetcher Function

Define a function that fetches data from your API. You can use `fetch` or `axios`.

```js
// api/posts.js
export const fetchPosts = async () => {
  const response = await fetch("https://jsonplaceholder.typicode.com/posts");
  if (!response.ok) {
    throw new Error("Network response was not ok");
  }
  return response.json();
};
```

```js
// api/posts.js
import axios from "axios";
export const fetchPosts = async () => {
  try {
    const response = await axios.get("https://jsonplaceholder.typicode.com/posts");
    return response.data;
  } catch (error) {
    throw new Error(error.response?.statusText || "Network request failed");
  }
};
```

#### 4. Use React Query in a Component

Use `useQuery` to fetch data and handle loading, error, and success states automatically.

```js
import { useQuery } from "@tanstack/react-query";
import { fetchPosts } from "./api/posts";

export default function PostsList() {
  const { data, isLoading, isError, error } = useQuery({
    // the path becomes the queryKey here,
      // /posts --> ["posts"]
      // /posts/1 --> ["posts", 1]
      // /posts/2 --> ["posts", 2]
      // or for dynamic route
      // /posts/:id --> ["posts", post.id]
      // /posts/:id/comments --> ["posts", post.id, "comments"]
    queryKey: ["posts"],
    // the queryFn is a Callback Function that returns a promise
    queryFn: fetchPosts,
  });

  if (isLoading) return <p>Loading...</p>;
  if (isError) return <p>Error: {error.message}</p>;

  return (
    <ul>
      {data.map((post) => (
        <li key={post.id}>
          <h3>{post.title}</h3>
          <p>{post.body}</p>
        </li>
      ))}
    </ul>
  );
}
```

#### 5. Key Concepts

- **queryKey** ‚Üí Unique key for caching and refetching.
- **queryFn** ‚Üí Function returning a promise (fetcher).
- **Automatic caching** ‚Üí Data is cached and updated automatically.
- **Stale time & refetch** ‚Üí Configurable to control updates.
- **Devtools** ‚Üí Visualize query cache and state in the browser.

---

## 1Ô∏è‚É£ Core Concepts

### **QueryClient**  

- **Purpose:** Central object that manages queries, mutations, cache, and default configurations.  
- **Key Options:**
      - `staleTime` ‚Äì The time during which cached data is considered fresh. While data is ‚Äúfresh,‚Äù React Query will not automatically refetch it when a component mounts or window refocuses.
      - `cacheTime` ‚ÄìThe time after which unused (inactive) cached data is garbage-collected. ‚ÄúUnused‚Äù means no active queries or components are currently subscribing to it.
      - `refetchOnWindowFocus` ‚Äì Refetch queries when window regains focus.  
      - More key options are listed below

- **Example:**

```js
// src/main.jsx
import { QueryClient } from "@tanstack/react-query";

const queryClient = new QueryClient({
  // Default options: `staleTime`, `cacheTime`, `refetchOnWindowFocus`.
  // here we are just create a QueryClient with Default Options
  defaultOptions: {
    queries: {
      // Configure how long the data should remain fresh, or won't turn into stale value.
      // Default staleTime = 0 ms
      // lets keep the value fresh for one minute
      staleTime: 1000 * 60, // 1 minute

      //The default value of cacheTime in React Query is: 5 minutes (1000 * 60 * 5 ms)
      cacheTime: 1000 * 60 * 5, // 5 minutes

      // Fires when the browser window/tab regains focus. 
      // When the user switches to another tab or window and comes back, React Query will refetch queries that are stale.
      // This ensures the UI shows the most up-to-date data without the user needing to refresh manually.
      refetchOnWindowFocus: true,   // default, refetch when window refocuses
      // refetchOnWindowFocus: false  // never refetch automatically on focus
      // refetchOnWindowFocus: 'always' // always refetch even if data is fresh

      // Fires when a component mounts that uses the query.
      // On component mount, React Query decides whether to refetch based on the staleness of the data.
      // refetchOnMount: true        // Refetch if the data is stale
      // refetchOnMount: false       // Never refetch on mount
      refetchOnMount: 'always'    // default, Always refetch, even if data is fresh
      // Useful when you want to ensure the component always shows up-to-date data on mount.
      // Can be set to false if you trust the cached data and want instant UI without unnecessary network requests.
    },
  },
});
```

- staleTime = 1 min
      - During this time, data is ‚Äúfresh.‚Äù
      - React Query will never show a loading state if a component mounts ‚Äî it just serves the cached data.

- After 1 min ‚Üí data becomes stale
      - React Query considers it stale and can refetch it in the background if refetchOnMount or refetchOnWindowFocus is enabled.
      - But the cached data is still available, so the UI can display stale data immediately instead of showing Loading....

- cacheTime = 5 min
      - Even if no component is using the query, React Query keeps the data in memory for 5 minutes.
      - If a component mounts within that 5 minutes, it gets stale data immediately while the background refetch happens.
      - Only after 5 minutes of inactivity is the cache removed ‚Äî then a new fetch will show Loading....

### **QueryClientProvider**

- Purpose: Wrap your app to provide the QueryClient instance globally.
- Example:

```js
import { QueryClientProvider } from "@tanstack/react-query";
import { ReactQueryDevtools } from "@tanstack/react-query-devtools";

// Create a Client
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      // every defalut query you want to give goes here.
    }
  }
});

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <MyAppComponents />
      {/* if you want to use react query devtools */}
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  );
}
```

### **useQuery**

- Purpose: Fetch and cache data from an API. Handles loading, error, and success automatically.
- Key Options: same Key Options as before
- Example:

```js
import { useQuery } from "@tanstack/react-query";

const fetchUsers = async () => {
  const res = await fetch("https://jsonplaceholder.typicode.com/users");
  if (!res.ok) throw new Error("Failed to fetch users");
  return res.json();
};

export default function UsersList() {
  const { data, isLoading, isError, error } = useQuery({
    queryKey: ["users"],
    queryFn: fetchUsers,
    staleTime: 1000 * 60, // 1 min
    retry: 2,
  });

  if (isLoading) return <p>Loading...</p>;
  if (isError) return <p>Error: {error.message}</p>;

  return (
    <ul>
      {data.map(user => <li key={user.id}>{user.name}</li>)}
    </ul>
  );
}
```

To know more: [useQuery Reference](/reactapi/14.5.3.React%20Query%20Ref)

### **useMutation**

- Purpose: Perform POST, PUT, PATCH, DELETE operations with automatic cache updates.
- Key Options:
      - `onSuccess` ‚Äì Called after successful mutation.
      - `onError` ‚Äì Called if mutation fails.
      - `onSettled` ‚Äì Called after either success or error.
- Example:

```js
import { useMutation, useQueryClient } from "@tanstack/react-query";

const addUser = async (user) => {
  const res = await fetch("https://jsonplaceholder.typicode.com/users", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(user),
  });
  if (!res.ok) throw new Error("Failed to add user");
  return res.json();
};

export default function AddUserForm() {
  const queryClient = useQueryClient();
  const mutation = useMutation(addUser, {
    onSuccess: () => {
      // Invalidate and refetch users query
      queryClient.invalidateQueries(["users"]);
    },
    onError: (error) => console.error("Error:", error),
  });

  const handleSubmit = (e) => {
    e.preventDefault();
    const user = { name: "John Doe" };
    mutation.mutate(user);
  };

  return <button onClick={handleSubmit}>Add User</button>;
}
```

### **useQueryClient**

- Purpose: Access and manipulate the query cache manually.
- Common Use Cases:
      - Invalidate queries
      - Prefetch queries
      - Update cached data optimistically
- Example:

```js
import { useQueryClient } from "@tanstack/react-query";

const queryClient = useQueryClient();
// refetch users
queryClient.invalidateQueries(["users"]); 
// optimistic update
queryClient.setQueryData(["users"], oldData => [...oldData, newUser]); 
```

### React Query Achitecture Map

```txt
               ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
               ‚îÇ      UI Component (Hook)   ‚îÇ
               ‚îÇ   e.g. useQuery/useMutation‚îÇ
               ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                              ‚îÇ
                              ‚ñº
               ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
               ‚îÇ QueryClient (central brain)‚îÇ
               ‚îÇ - Stores all queries       ‚îÇ
               ‚îÇ - Caches results           ‚îÇ
               ‚îÇ - Manages observers        ‚îÇ
               ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                              ‚îÇ
         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         ‚ñº                                          ‚ñº
 ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
 ‚îÇ Query Cache          ‚îÇ                  ‚îÇ Mutation Cache        ‚îÇ
 ‚îÇ - Data (stale/fresh) ‚îÇ                  ‚îÇ - Pending mutations   ‚îÇ
 ‚îÇ - Status (loading...)‚îÇ                  ‚îÇ - Retry/failure state ‚îÇ
 ‚îÇ - Timestamps         ‚îÇ                  ‚îÇ - Garbage collection  ‚îÇ
 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
             ‚îÇ                                          ‚îÇ
             ‚ñº                                          ‚ñº
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚îÇ Query Observer            ‚îÇ              ‚îÇ Mutation Observer         ‚îÇ
   ‚îÇ - Subscribes to cache     ‚îÇ              ‚îÇ - Subscribes to mutation  ‚îÇ
   ‚îÇ - Notifies components     ‚îÇ              ‚îÇ - Triggers UI updates     ‚îÇ
   ‚îÇ - Applies retry logic     ‚îÇ              ‚îÇ - Retries if configured   ‚îÇ
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                 ‚îÇ                                           ‚îÇ
                 ‚ñº                                           ‚ñº
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ Query Function (async)‚îÇ                   ‚îÇ Mutation Function      ‚îÇ
        ‚îÇ - fetch('/api/data')  ‚îÇ                   ‚îÇ - POST/PUT/DELETE reqs ‚îÇ
        ‚îÇ - Axios/Fetch/GraphQL ‚îÇ                   ‚îÇ - Sends updates        ‚îÇ
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                     ‚îÇ                                           ‚îÇ
                     ‚ñº                                           ‚ñº
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ Server / API / Database ‚îÇ                  ‚îÇ Server / API / Database ‚îÇ
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

```txt
                ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                ‚îÇ        QueryClient         ‚îÇ
                ‚îÇ  (Central Manager/Cache)   ‚îÇ
                ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                               ‚îÇ
            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
            ‚îÇ                  ‚îÇ                        ‚îÇ
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚îÇ Query Cache      ‚îÇ ‚îÇ Mutation Cache  ‚îÇ ‚îÇ Devtools (UI)    ‚îÇ
   ‚îÇ - Stores queries ‚îÇ ‚îÇ - Stores pending‚îÇ ‚îÇ - Observes state ‚îÇ
   ‚îÇ - Data + status  ‚îÇ ‚îÇ   mutations     ‚îÇ ‚îÇ - Debugging      ‚îÇ
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
            ‚îÇ                  ‚îÇ                        ‚îÇ
            ‚îÇ                  ‚îÇ                        ‚îÇ
 ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îÇ                        ‚îÇ
 ‚îÇ Query Observer     ‚îÇ        ‚îÇ                        ‚îÇ
 ‚îÇ (per component)    ‚îÇ        ‚îÇ                        ‚îÇ
 ‚îÇ - Subscribes to    ‚îÇ        ‚îÇ                        ‚îÇ
 ‚îÇ   query updates    ‚îÇ        ‚îÇ                        ‚îÇ
 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îÇ                        ‚îÇ
           ‚îÇ                   ‚îÇ                        ‚îÇ
 ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
 ‚îÇ React Hook Layer  ‚îÇ   ‚îÇ Mutation Hook ‚îÇ       ‚îÇ Utilities      ‚îÇ
 ‚îÇ (useQuery,        ‚îÇ   ‚îÇ (useMutation) ‚îÇ       ‚îÇ Hydration,     ‚îÇ
 ‚îÇ useInfiniteQuery, ‚îÇ   ‚îÇ - Trigger API ‚îÇ       ‚îÇ Suspense, etc. ‚îÇ
 ‚îÇ useSuspenseQuery, ‚îÇ   ‚îÇ - Update cache‚îÇ       ‚îÇ                ‚îÇ
 ‚îÇ etc.)             ‚îÇ   ‚îÇ - Invalidate  ‚îÇ       ‚îÇ                ‚îÇ
 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ                   ‚îÇ
           ‚îÇ                   ‚îÇ
 ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
 ‚îÇ                        Data Fetcher                        ‚îÇ
 ‚îÇ (Axios, fetch, GraphQL, REST, gRPC, etc.)                  ‚îÇ
 ‚îÇ - Executes actual network request                          ‚îÇ
 ‚îÇ - Returns data or error                                    ‚îÇ
 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                    ‚îÇ
          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
          ‚îÇ Query Lifecycle      ‚îÇ
          ‚îÇ - idle ‚Üí loading ‚Üí   ‚îÇ
          ‚îÇ   success/error      ‚îÇ
          ‚îÇ - retries + backoff  ‚îÇ
          ‚îÇ - garbage collection ‚îÇ
          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                    ‚îÇ
         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         ‚îÇ Cache Policies       ‚îÇ
         ‚îÇ - staleTime          ‚îÇ
         ‚îÇ - cacheTime          ‚îÇ
         ‚îÇ - refetchOnWindow    ‚îÇ
         ‚îÇ   Focus, Reconnect   ‚îÇ
         ‚îÇ - background updates ‚îÇ
         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                    ‚îÇ
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ React Component Rendering            ‚îÇ
        ‚îÇ - Reads from cache (fast UI)         ‚îÇ
        ‚îÇ - Subscribes to changes (auto sync)  ‚îÇ
        ‚îÇ - Suspense fallback if enabled       ‚îÇ
        ‚îÇ - ErrorBoundary for failures         ‚îÇ
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### React Query Workflow

#### 1. Component Mounts

- Calls **`useQuery` / `useInfiniteQuery` / `useSuspenseQuery`**.
- Hook connects to **Query Observer**, which checks the **Query Cache** inside `QueryClient`.

#### 2. Cache Check

- **If data is fresh** (within `staleTime`) ‚Üí return **cached data instantly** (no network).
- **If data is stale or missing** ‚Üí trigger **fetch** from **Data Fetcher**.

#### 3. QueryClient Controls

- Tracks query **state**: `idle`, `loading`, `success`, `error`.
- Manages:
  - **Retries** (with exponential backoff).
  - **Garbage collection** (based on `cacheTime`).
  - **Refetching policies**:
    - On **window focus**.
    - On **reconnect**.
    - On **intervals**.

#### 4. Query Updates

- **Cache updated** with new data (organized by `queryKey`).
- All **subscribed components automatically re-render** with latest data.

#### 5. Mutations (`useMutation`)

- Executes `mutationFn` (e.g., `POST`, `PUT`, `DELETE` API call).
- Features:
  - **Optimistic updates** ‚Üí UI updates before server confirms.
  - **Invalidate queries** ‚Üí triggers auto-refetch for related queries.
  - **Rollback on error** ‚Üí revert changes if mutation fails.

#### 6. Suspense + Error Boundaries

- **`useSuspenseQuery`** ‚Üí UI **suspends** until data resolves.
- If query fails ‚Üí **Error Boundary** (or `useQueryErrorResetBoundary`) catches and handles error.

#### 7. Hydration (SSR / SSG)

- Server **prefetches data**.
- Data sent to client as **dehydrated JSON**.
- Client **hydrates** into `QueryClient` cache ‚Üí avoids unnecessary refetch.

#### 8. Devtools

- Visualize queries, cache, and mutations in **real-time**.
- Helps with **debugging** and **cache inspection**.

---

## 2Ô∏è‚É£ Query Keys and Cache

### A. Query Keys

**What they are**  
Query keys uniquely identify cached data. React Query uses them to store, look up, refetch, and invalidate results.
**Shape and best practices**

- Use **arrays** as keys: `['users']`, `['user', userId]`, `['posts', { page, sort }]`.
- Include every **input that affects the response** (e.g., filters, pagination, auth scope).
- Use **serializable values** (strings, numbers, booleans, plain objects). Avoid functions/instances.
- Centralize keys in a **key-factory** to avoid typos and keep consistency.

- **Key factory pattern (recommended)**

```tsx
// keys/users.ts
export const usersKeys = {
  all: () => ['users'] as const,
  lists: () => [...usersKeys.all(), 'list'] as const,
  list: (filters: { page?: number; q?: string } = {}) =>
    [...usersKeys.lists(), filters] as const,
  details: () => [...usersKeys.all(), 'detail'] as const,
  detail: (id: number | string) => [...usersKeys.details(), id] as const,
};
```

Using keys in queries

```tsx
import { useQuery } from '@tanstack/react-query';
import { usersKeys } from './keys/users';
import axios from 'axios';

const fetchUsers = async (filters: { page?: number; q?: string }) => {
  const { data } = await axios.get('/api/users', { params: filters });
  return data as { items: any[]; page: number; total: number };
};

const fetchUser = async (id: number) => {
  const { data } = await axios.get(`/api/users/${id}`);
  return data as { id: number; name: string };
};

export function UsersList({ page, q }: { page: number; q?: string }) {
  const { data, isLoading } = useQuery({
    queryKey: usersKeys.list({ page, q }),
    queryFn: () => fetchUsers({ page, q }),
    staleTime: 60_000,
  });

  if (isLoading) return <p>Loading...</p>;
  return <pre>{JSON.stringify(data, null, 2)}</pre>;
}

export function UserDetail({ id }: { id: number }) {
  const { data } = useQuery({
    queryKey: usersKeys.detail(id),
    queryFn: () => fetchUser(id),
  });
  return <div>{data?.name}</div>;
}
```

---

### B. Cache Management

- React Query caches data by query key.
- Multiple components using the same key share the same cache entry.
- Key cache operations you‚Äôll use daily:

#### **1. Invalidation (queryClient.invalidateQueries)**

Marks matching queries as stale and triggers refetch for active ones.

```tsx
import { useMutation, useQueryClient } from '@tanstack/react-query';
import axios from 'axios';
import { usersKeys } from './keys/users';

type NewUser = { name: string };

const createUser = (payload: NewUser) => axios.post('/api/users', payload);

export function CreateUserButton() {
  const queryClient = useQueryClient();

  const mutation = useMutation({
    mutationFn: createUser,
    onSuccess: () => {
      // Invalidate all user list queries (any filters)
      queryClient.invalidateQueries({ queryKey: usersKeys.lists() });
      // Or invalidate a single detail:
      // queryClient.invalidateQueries({ queryKey: usersKeys.detail(id) });
    },
  });

  return (
    <button onClick={() => mutation.mutate({ name: 'Alice' })}>
      Create User
    </button>
  );
}
```

- **Notes**
- Use exact: true to target a single key only.
- Without exact, partial-match behavior applies (e.g., `['users', 'list']` will match `['users', 'list', {...filters}]`).

```tsx
// Exact invalidation (only that specific key)
queryClient.invalidateQueries({
  queryKey: usersKeys.detail(42),
  exact: true,
});
```

#### 2. Refetching (queryClient.refetchQueries)

- Actively refetch matching queries now, even if they are still fresh.

```tsx
// Force refetch all active user lists
await queryClient.refetchQueries({
  queryKey: usersKeys.lists(),
  type: 'active',      // 'active' | 'inactive' | 'all'
});
```

#### 3. Prefetching (queryClient.prefetchQuery)

- Warm the cache before a component mounts or a route changes.

```tsx
import { queryClient } from './queryClient'; // your app-level instance
import { usersKeys } from './keys/users';
import axios from 'axios';

const fetchUsers = async (filters: { page?: number }) => {
  const { data } = await axios.get('/api/users', { params: filters });
  return data;
};

// Example: prefetch on link hover
export function UsersLink() {
  const prefetch = () =>
    queryClient.prefetchQuery({
      queryKey: usersKeys.list({ page: 1 }),
      queryFn: () => fetchUsers({ page: 1 }),
      staleTime: 30_000,
    });

  return (
    <a href="/users" onMouseEnter={prefetch}>
      Users
    </a>
  );
}
```

#### 4. Manual cache updates (setQueryData, getQueryData)

- Update cached data synchronously without refetching. Great after mutations or for optimistic UI.

```tsx
import { useMutation, useQueryClient } from '@tanstack/react-query';
import axios from 'axios';
import { usersKeys } from './keys/users';

type User = { id: number; name: string };
const updateUser = (id: number, payload: Partial<User>) =>
  axios.put(`/api/users/${id}`, payload).then(r => r.data as User);

export function RenameUser({ id }: { id: number }) {
  const queryClient = useQueryClient();

  const mutation = useMutation({
    mutationFn: (name: string) => updateUser(id, { name }),
    onMutate: async (newName) => {
      await queryClient.cancelQueries({ queryKey: usersKeys.detail(id) });

      const prev = queryClient.getQueryData<User>(usersKeys.detail(id));

      // Optimistically update the user detail
      queryClient.setQueryData<User>(usersKeys.detail(id), (old) =>
        old ? { ...old, name: newName } : old
      );

      // Optionally update any lists that contain this user
      queryClient.setQueryData<{ items: User[] } | undefined>(
        usersKeys.list({ page: 1 }), // example: known list
        (old) =>
          old
            ? {
                ...old,
                items: old.items.map((u) => (u.id === id ? { ...u, name: newName } : u)),
              }
            : old
      );

      return { prev };
    },
    onError: (_err, _vars, ctx) => {
      // Rollback on error
      if (ctx?.prev) {
        queryClient.setQueryData(usersKeys.detail(id), ctx.prev);
      }
    },
    onSettled: () => {
      // Ensure server truth wins eventually
      queryClient.invalidateQueries({ queryKey: usersKeys.detail(id) });
      queryClient.invalidateQueries({ queryKey: usersKeys.lists() });
    },
  });

  return (
    <button onClick={() => mutation.mutate('New Name')}>
      Rename
    </button>
  );
}
```

- **Quick utilities**

```tsx
// Read cache (undefined if not present)
const cached = queryClient.getQueryData(usersKeys.detail(42));

// Write/replace cache synchronously
queryClient.setQueryData(usersKeys.detail(42), { id: 42, name: 'Alice' });

// Ensure (get if present, otherwise fetch)
const user = await queryClient.ensureQueryData({
  queryKey: usersKeys.detail(42),
  queryFn: () => axios.get('/api/users/42').then(r => r.data),
});
```

---

### C. How staleness and garbage collection affect cache

- staleTime: How long data is considered fresh. Fresh data won‚Äôt refetch on focus/mount by default.
- gcTime: How long inactive cache entries live before being garbage-collected.
- Data can be fresh in cache and reused instantly, stale but still available (may refetch), or gc‚Äôed (removed, requires new fetch).

```tsx
useQuery({
  queryKey: usersKeys.list({ page: 1 }),
  queryFn: () => fetchUsers({ page: 1 }),
  staleTime: 60_000, // stays fresh for 1 min
  gcTime: 300_000,   // kept in cache for 5 min after unused
});
```

---

### D. Choosing between invalidation vs manual updates

- Use invalidation when:
      - You don‚Äôt know which lists/filters are affected.
      - The update is complex or server-side logic changes the shape.
- Use setQueryData when:
      - You know exactly which key(s) to update.
      - You want instant UI (optimistic updates) and will still invalidate afterward to reconcile.

```tsx
// Simple flow after mutation:
onSuccess: () => {
  queryClient.invalidateQueries({ queryKey: usersKeys.lists() });
  queryClient.invalidateQueries({ queryKey: usersKeys.detail(id) });
}
```

---

## 3Ô∏è‚É£ Fetching Patterns

### üîπ Basic GET Requests

Use `useQuery` to fetch simple data.

```tsx
import { useQuery } from "@tanstack/react-query";

const fetchUsers = async () => {
  const res = await fetch("https://jsonplaceholder.typicode.com/users");
  return res.json();
};

export default function Users() {
  const { data, isLoading, error } = useQuery({
    queryKey: ["users"],
    queryFn: fetchUsers,
  });

  if (isLoading) return <p>Loading...</p>;
  if (error) return <p>Error fetching users</p>;

  return (
    <ul>
      {data.map((user: any) => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}
```

---

### üîπ Dependent Queries

Run query B only after A succeeds.

```tsx
import { useQuery } from "@tanstack/react-query";

const fetchUser = async (id: number) =>
  (await fetch(`https://jsonplaceholder.typicode.com/users/${id}`)).json();

const fetchPostsByUser = async (id: number) =>
  (await fetch(`https://jsonplaceholder.typicode.com/users/${id}/posts`)).json();

export default function DependentQueries() {
  const userId = 1;

  const { data: user } = useQuery({
    queryKey: ["user", userId],
    queryFn: () => fetchUser(userId),
  });

  const { data: posts } = useQuery({
    queryKey: ["posts", user?.id],
    queryFn: () => fetchPostsByUser(user!.id),
    enabled: !!user, // Run only when user is loaded
  });

  return (
    <div>
      <h2>{user?.name}'s Posts</h2>
      <ul>
        {posts?.map((p: any) => (
          <li key={p.id}>{p.title}</li>
        ))}
      </ul>
    </div>
  );
}
```

---

### üîπ Paginated Queries

Page-based fetching with useQuery.

```tsx
import { useState } from "react";
import { useQuery } from "@tanstack/react-query";

const fetchPage = async (page: number) =>
  (await fetch(`https://jsonplaceholder.typicode.com/posts?_page=${page}&_limit=5`)).json();

export default function PaginatedQuery() {
  const [page, setPage] = useState(1);

  const { data, isLoading } = useQuery({
    queryKey: ["posts", page],
    queryFn: () => fetchPage(page),
    keepPreviousData: true, // Keeps old data while fetching new
  });

  return (
    <div>
      <ul>
        {data?.map((post: any) => (
          <li key={post.id}>{post.title}</li>
        ))}
      </ul>
      <button onClick={() => setPage((p) => Math.max(p - 1, 1))}>Previous</button>
      <button onClick={() => setPage((p) => p + 1)}>Next</button>
    </div>
  );
}
```

### üîπ Infinite Queries

Cursor-based infinite scroll with useInfiniteQuery.

```tsx
import { useInfiniteQuery } from "@tanstack/react-query";

const fetchPosts = async ({ pageParam = 1 }) =>
  (await fetch(`https://jsonplaceholder.typicode.com/posts?_page=${pageParam}&_limit=5`)).json();

export default function InfiniteQuery() {
  const {
    data,
    fetchNextPage,
    hasNextPage,
    isFetchingNextPage,
  } = useInfiniteQuery({
    queryKey: ["infinitePosts"],
    queryFn: fetchPosts,
    getNextPageParam: (lastPage, allPages) =>
      lastPage.length ? allPages.length + 1 : undefined,
  });

  return (
    <div>
      {data?.pages.map((page, i) => (
        <ul key={i}>
          {page.map((post: any) => (
            <li key={post.id}>{post.title}</li>
          ))}
        </ul>
      ))}
      <button onClick={() => fetchNextPage()} disabled={!hasNextPage || isFetchingNextPage}>
        {isFetchingNextPage ? "Loading..." : "Load More"}
      </button>
    </div>
  );
}
```

### üîπ Conditional Queries

Control query execution using enabled.

```tsx
import { useState } from "react";
import { useQuery } from "@tanstack/react-query";

const fetchUser = async (id: number) =>
  (await fetch(`https://jsonplaceholder.typicode.com/users/${id}`)).json();

export default function ConditionalQuery() {
  const [userId, setUserId] = useState<number | null>(null);

  const { data, isLoading } = useQuery({
    queryKey: ["user", userId],
    queryFn: () => fetchUser(userId!),
    enabled: !!userId, // Run only when userId exists
  });

  return (
    <div>
      <button onClick={() => setUserId(1)}>Load User</button>
      {isLoading && <p>Loading...</p>}
      {data && <p>{data.name}</p>}
    </div>
  );
}
```

---

## 4Ô∏è‚É£ Mutations

### **Basic Mutation**

Create, update, or delete data.

```tsx
import { useMutation } from "@tanstack/react-query";

async function addTodoApi(newTodo: string) {
  return { id: Date.now(), text: newTodo };
}

export default function BasicMutation() {
  const mutation = useMutation({
    mutationFn: addTodoApi,
    onSuccess: (data) => {
      console.log("Added:", data);
    },
  });

  return (
    <div>
      <button onClick={() => mutation.mutate("Learn React Query")}>
        Add Todo
      </button>
    </div>
  );
}
```

### **Optimistic Updates**

Update UI before mutation is confirmed.

```tsx
import { useMutation, useQueryClient } from "@tanstack/react-query";

async function addTodoApi(newTodo: string) {
  return { id: Date.now(), text: newTodo };
}

export default function OptimisticUpdate() {
  const queryClient = useQueryClient();

  const mutation = useMutation({
    mutationFn: addTodoApi,
    onMutate: async (newTodo) => {
      await queryClient.cancelQueries({ queryKey: ["todos"] });

      const previousTodos = queryClient.getQueryData<{ id: number; text: string }[]>(["todos"]);

      queryClient.setQueryData(["todos"], (old: any) => [
        ...(old || []),
        { id: Date.now(), text: newTodo },
      ]);

      return { previousTodos };
    },
    onError: (_err, _newTodo, context) => {
      queryClient.setQueryData(["todos"], context?.previousTodos);
    },
    onSettled: () => {
      queryClient.invalidateQueries({ queryKey: ["todos"] });
    },
  });

  return (
    <div>
      <button onClick={() => mutation.mutate("Optimistic Todo")}>
        Add Optimistic Todo
      </button>
    </div>
  );
}
```

### **Error Handling**

Rollback updates on failure.

```tsx
import { useMutation } from "@tanstack/react-query";

async function failApi() {
  throw new Error("Something went wrong!");
}

export default function ErrorHandling() {
  const mutation = useMutation({
    mutationFn: failApi,
    onError: (error: Error) => {
      alert(error.message);
    },
  });

  return (
    <div>
      <button onClick={() => mutation.mutate()}>
        Trigger Error
      </button>
    </div>
  );
}
```

### **Invalidate Queries**

Automatically refresh related queries after mutation.

```tsx
import { useMutation, useQueryClient } from "@tanstack/react-query";

async function addTodoApi(newTodo: string) {
  return { id: Date.now(), text: newTodo };
}

export default function InvalidateQueries() {
  const queryClient = useQueryClient();

  const mutation = useMutation({
    mutationFn: addTodoApi,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["todos"] });
    },
  });

  return (
    <div>
      <button onClick={() => mutation.mutate("Invalidate Todo")}>
        Add & Refresh
      </button>
    </div>
  );
}
```

---

## 5Ô∏è‚É£ Query Lifecycle & Refetching

- **Stale vs Fresh Data**
- **Refetch on window focus**
- **Refetch on reconnect**
- **Polling / Interval Refetching**
- **Suspense Mode**
      - Use with React Suspense for declarative loading states.

```tsx
"use client";

import { Suspense } from "react";
import { useQuery } from "@tanstack/react-query";

// Fake APIs
async function fetchUser() {
  return { id: 1, name: "Alice" };
}
async function fetchMessage() {
  return "Hello from server";
}
async function fetchStatus() {
  return "Network status OK";
}
async function fetchTime() {
  return new Date().toLocaleTimeString();
}
async function fetchProfile() {
  return { name: "Sourav", role: "Frontend Dev" };
}

// --- Suspense child ---
function Profile() {
  const { data } = useQuery({
    queryKey: ["profile"],
    queryFn: fetchProfile,
    suspense: true,
  });
  return <p>üë§ Profile: {data?.name} - {data?.role}</p>;
}

export default function RefetchingDemo() {
  // 1. Stale vs Fresh
  const userQuery = useQuery({
    queryKey: ["user"],
    queryFn: fetchUser,
    staleTime: 5000, // stays fresh for 5 sec
  });

  // 2. Refetch on focus
  const messageQuery = useQuery({
    queryKey: ["message"],
    queryFn: fetchMessage,
    refetchOnWindowFocus: true,
  });

  // 3. Refetch on reconnect
  const statusQuery = useQuery({
    queryKey: ["status"],
    queryFn: fetchStatus,
    refetchOnReconnect: true,
  });

  // 4. Polling (every 2 sec)
  const timeQuery = useQuery({
    queryKey: ["time"],
    queryFn: fetchTime,
    refetchInterval: 2000,
  });

  return (
    <div style={{ padding: "1rem", fontFamily: "sans-serif" }}>
      <h2>‚ö° React Query Refetching Demo</h2>

      <h3>1Ô∏è‚É£ Stale vs Fresh Data</h3>
      <p>User: {userQuery.data?.name}</p>
      <p>{userQuery.isFetching ? "Fetching fresh..." : "Using cached (fresh) data"}</p>

      <h3>2Ô∏è‚É£ Refetch on Window Focus</h3>
      <p>{messageQuery.data}</p>

      <h3>3Ô∏è‚É£ Refetch on Reconnect</h3>
      <p>{statusQuery.data}</p>

      <h3>4Ô∏è‚É£ Polling / Interval Refetching</h3>
      <p>Server Time: {timeQuery.data}</p>

      <h3>5Ô∏è‚É£ Suspense Mode</h3>
      <Suspense fallback={<p>Loading Profile...</p>}>
        <Profile />
      </Suspense>
    </div>
  );
}
```

---

## 6Ô∏è‚É£ Error Handling

- Global error handling via `QueryClient`.
- Per-query error handling using `onError`.
- Retry logic and exponential backoff.

```tsx
"use client";

import { QueryClient, QueryClientProvider, useQuery } from "@tanstack/react-query";
import { useState } from "react";

// -------------------------
// Fake APIs
// -------------------------
async function fetchFailingApi() {
  throw new Error("‚ùå Server is down!");
}

async function fetchSometimesApi() {
  if (Math.random() < 0.7) throw new Error("‚ö†Ô∏è Random failure, try again!");
  return "‚úÖ Success after retry!";
}

// -------------------------
// Per-query Error Handling
// -------------------------
function PerQueryErrorExample() {
  const { data, error, isError, refetch } = useQuery({
    queryKey: ["perQuery"],
    queryFn: fetchFailingApi,
    retry: false, // don't retry here
    onError: (err: Error) => {
      console.log("Per-query error handled:", err.message);
    },
  });

  return (
    <div>
      <h3>Per-Query Error Handling</h3>
      <button onClick={() => refetch()}>Fetch</button>
      {isError && <p style={{ color: "red" }}>Error: {(error as Error).message}</p>}
      {data && <p>{data}</p>}
    </div>
  );
}

// -------------------------
// Retry + Exponential Backoff
// -------------------------
function RetryExample() {
  const { data, error, isError, isFetching, refetch } = useQuery({
    queryKey: ["retryExample"],
    queryFn: fetchSometimesApi,
    retry: 3, // retry up to 3 times
    retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 5000), // exponential backoff
  });

  return (
    <div>
      <h3>Retry with Exponential Backoff</h3>
      <button onClick={() => refetch()}>Fetch</button>
      {isFetching && <p>‚è≥ Trying...</p>}
      {isError && <p style={{ color: "red" }}>Error: {(error as Error).message}</p>}
      {data && <p>{data}</p>}
    </div>
  );
}

// -------------------------
// Global Error Handling
// -------------------------
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      onError: (err) => {
        console.error("üåç Global error handler:", (err as Error).message);
      },
    },
  },
});

function GlobalErrorExample() {
  const { error, isError, refetch } = useQuery({
    queryKey: ["globalError"],
    queryFn: fetchFailingApi,
    retry: false,
  });

  return (
    <div>
      <h3>Global Error Handling</h3>
      <button onClick={() => refetch()}>Fetch</button>
      {isError && <p style={{ color: "red" }}>Error: {(error as Error).message}</p>}
    </div>
  );
}

// -------------------------
// Main Demo Component
// -------------------------
export default function ErrorHandlingDemo() {
  const [client] = useState(queryClient);

  return (
    <QueryClientProvider client={client}>
      <div style={{ padding: "1rem", fontFamily: "sans-serif" }}>
        <h2>‚ö° React Query Error Handling Demo</h2>
        <GlobalErrorExample />
        <hr />
        <PerQueryErrorExample />
        <hr />
        <RetryExample />
      </div>
    </QueryClientProvider>
  );
}
```

---

## 7Ô∏è‚É£ Advanced Features

- **Query Cancellation**
      - Cancel in-flight queries when component unmounts.
- **Background Fetching**
      - Refresh data silently.
- **Infinite Scrolling**
      - Load more data dynamically as user scrolls.
- **Prefetching**
      - Preload data before user navigates.

```tsx
"use client";

import {
  QueryClient,
  QueryClientProvider,
  useInfiniteQuery,
  useQuery,
  useQueryClient,
} from "@tanstack/react-query";
import { useEffect, useState } from "react";

// -------------------------
// Fake APIs
// -------------------------
async function fetchUsers(page: number) {
  await new Promise((res) => setTimeout(res, 1000)); // simulate delay
  return Array.from({ length: 5 }, (_, i) => ({
    id: page * 10 + i,
    name: `User ${page * 10 + i}`,
  }));
}

async function fetchProfile() {
  await new Promise((res) => setTimeout(res, 800));
  return { name: "Alice", role: "Admin" };
}

// -------------------------
// 1. Query Cancellation
// -------------------------
function QueryCancellation() {
  const { data, isFetching } = useQuery({
    queryKey: ["profile"],
    queryFn: fetchProfile,
  });

  // query auto-cancels when component unmounts
  useEffect(() => {
    return () => {
      console.log("üî¥ Query auto-cancelled on unmount");
    };
  }, []);

  return (
    <div>
      <h3>1Ô∏è‚É£ Query Cancellation</h3>
      {isFetching ? <p>Loading...</p> : <p>{data?.name} - {data?.role}</p>}
    </div>
  );
}

// -------------------------
// 2. Background Fetching
// -------------------------
function BackgroundFetching() {
  const { data, isFetching } = useQuery({
    queryKey: ["background"],
    queryFn: fetchProfile,
    refetchInterval: 5000, // refresh silently every 5s
  });

  return (
    <div>
      <h3>2Ô∏è‚É£ Background Fetching</h3>
      <p>{data?.name} - {data?.role}</p>
      {isFetching && <p style={{ fontSize: "12px" }}>Refreshing in background...</p>}
    </div>
  );
}

// -------------------------
// 3. Infinite Scrolling
// -------------------------
function InfiniteScroll() {
  const {
    data,
    fetchNextPage,
    hasNextPage,
    isFetchingNextPage,
  } = useInfiniteQuery({
    queryKey: ["users"],
    queryFn: ({ pageParam = 0 }) => fetchUsers(pageParam),
    getNextPageParam: (_lastPage, pages) => {
      if (pages.length < 3) return pages.length; // max 3 pages
      return undefined;
    },
  });

  return (
    <div>
      <h3>3Ô∏è‚É£ Infinite Scrolling</h3>
      {data?.pages.map((page, i) => (
        <div key={i}>
          {page.map((user) => (
            <p key={user.id}>{user.name}</p>
          ))}
        </div>
      ))}
      <button onClick={() => fetchNextPage()} disabled={!hasNextPage || isFetchingNextPage}>
        {isFetchingNextPage ? "Loading..." : hasNextPage ? "Load More" : "No More"}
      </button>
    </div>
  );
}

// -------------------------
// 4. Prefetching
// -------------------------
function Prefetching() {
  const queryClient = useQueryClient();
  const [show, setShow] = useState(false);

  const handleHover = () => {
    queryClient.prefetchQuery({
      queryKey: ["prefetchProfile"],
      queryFn: fetchProfile,
    });
    console.log("‚ö° Prefetched profile data!");
  };

  const { data } = useQuery({
    queryKey: ["prefetchProfile"],
    queryFn: fetchProfile,
    enabled: show, // only fetch when shown
  });

  return (
    <div>
      <h3>4Ô∏è‚É£ Prefetching</h3>
      <button onMouseEnter={handleHover} onClick={() => setShow(true)}>
        Hover to Prefetch ‚Üí Click to Show
      </button>
      {show && <p>{data?.name} - {data?.role}</p>}
    </div>
  );
}

// -------------------------
// Main Demo
// -------------------------
const queryClient = new QueryClient();

export default function AdvancedFeaturesDemo() {
  return (
    <QueryClientProvider client={queryClient}>
      <div style={{ padding: "1rem", fontFamily: "sans-serif" }}>
        <h2>‚ö° React Query Advanced Features</h2>
        <QueryCancellation />
        <hr />
        <BackgroundFetching />
        <hr />
        <InfiniteScroll />
        <hr />
        <Prefetching />
      </div>
    </QueryClientProvider>
  );
}
```

---

## 8Ô∏è‚É£ Integration with Axios / Fetch

React Query does not enforce a specific HTTP client ‚Äî you can use **Axios** or the built-in **Fetch API** as query functions. The main idea is to return a promise that resolves with the data.

- **Using Fetch**  
  - Simple and built into JavaScript.  
  - Ideal for lightweight requests.  
  - Example:  

    ```js
    const fetchUsers = async () => {
      const res = await fetch('/api/users');
      if (!res.ok) throw new Error('Network response was not ok');
      return res.json();
    };
    ```

- **Using Axios**  
  - Provides additional features like interceptors, automatic JSON parsing, and better error handling.  
  - Good for projects requiring headers, tokens, or complex configs.  
  - Example:  

    ```js
    import axios from 'axios';

    const fetchUsers = async () => {
      const res = await axios.get('/api/users', {
        headers: { Authorization: `Bearer ${token}` }
      });
      return res.data;
    };
    ```

- **When to choose what?**  
  - Use **Fetch** if you want a lightweight, dependency-free approach.  
  - Use **Axios** if you need advanced features like interceptors, request cancellation, or custom headers frequently.  

> üîë Both Fetch and Axios integrate seamlessly with React Query, as long as the function returns a promise.

---

## 9Ô∏è‚É£ DevTools

The **React Query Devtools** are like a built-in **debug dashboard** for your app.  
They let you inspect queries, mutations, cache, and state in real time.

---

### üìå What You Can Inspect

#### 1. Cache

- Shows all queries stored in memory.
- Expand a query to see:
  - **Key** ‚Üí e.g. `["todos"]` or `["user", id]`.
  - **Data** ‚Üí cached server response.
  - **Status** ‚Üí `idle`, `loading`, `success`, or `error`.
  - **Timestamps** ‚Üí when last updated.

#### 2. Queries

- Inspect which queries are:
  - **Fresh** ‚Üí recently fetched, still valid (`staleTime` not passed).
  - **Stale** ‚Üí expired, will refetch on usage.
  - **Inactive** ‚Üí cached but not currently rendered.
- Manually **refetch** or **remove** a query.

#### 3. Mutations

- Inspect create/update/delete requests.
- See mutation states:
  - `idle`, `loading`, `error`, `success`.
- Retry or cancel a mutation manually.

#### 4. State

- Debug flags like:
  - **isFetching**
  - **retry count**
  - **errors**
- Understand why queries are refetching (or not).

---

### ‚öôÔ∏è Configuration

- **`initialIsOpen`**
  - `true` ‚Üí Devtools open by default.
  - `false` ‚Üí Closed until user clicks the floating React Query logo.
- **Position** can be moved (bottom-right is default).

---
