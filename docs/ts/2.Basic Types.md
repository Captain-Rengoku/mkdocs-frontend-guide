---
date: 
  created: 2025-11-06
---

# Basic Types and Type Inference, Annotations & Assertions

---

## Basic Types

```ts
// ‚úÖ Primitive Types
let yourname: string = "Alice";
let age: number = 30;
let isActive: boolean = true;
let nothing: null = null;
let notDefined: undefined = undefined;
let normalNum = 9007199254740991; // Max safe integer in JS
let bigIntValue: bigint = 9007199254740992n; // Beyond safe limit
// go to tsconfig.json and change "target" value to "ES2020"
console.log(bigIntValue + 1n); // 9007199254740993n
let symbolValue: symbol = Symbol("id");

// ‚úÖ Special Types
// variable should not be 'any' type like this
let anythingOne;
// Even if we give 'any' to this it will auto detect and convert to string.
// This is also known as Type Inference
let anythingTwo: any = "can be anything";
anythingTwo = 20;

let uncertain: unknown = 42;
if (typeof uncertain === "number")
    uncertain.toFixed();

function sayHi(): void {
    console.log("Hi");
}

function throwError(): never {
    throw new Error("Crash!");
}
// throwError()

// ‚úÖ Arrays and Tuples
let numbers: number[] = [1, 2, 3];
let names: Array<string> = ["Tom", "Jerry"];
// tuples are fixed means this [20, "score"] won't work
let tupleExample: [string, number] = ["score", 100];

// ‚úÖ Enums 1
enum Direction {
    Up,
    Down,
    Left,
    Right
}
let move: Direction = Direction.Up;

// ‚úÖ Enums 2
enum UserRoles {
    ADMIN = "admin",
    GUEST = "guest",
    SUPER_ADMIN = "super_admin"
}
let UserRole: UserRoles = UserRoles.ADMIN

// ‚úÖ Literal Types
let response: "yes" | "no" = "yes";

// ‚úÖ Type Aliases
type User = {
    username: string;
    age: number;
};
const user: User = { username: "Bob", age: 28 };

// ‚úÖ Reference Types (Objects, Arrays, Functions)
let person: { username: string; isEmployed: boolean } = {
    username: "Eve",
    isEmployed: true
};

let greet: (username: string) => string = (username) => `Hello, ${username}`;
```

---

## Type Inference, Annotations & Assertions

```ts
// ‚úÖ Type Inference
// TypeScript automatically infers the type based on the assigned value
let message = "Hello TypeScript";  // inferred as string
let count = 42;                    // inferred as number

// ‚úÖ Type Annotations
// You explicitly declare the type of a variable
let title: string = "Typed Title";
let isActive: boolean = true;
let total: number;
total = 100;

// ‚úÖ Type Assertions (Casting)
// You tell TypeScript the exact type of a value (used with `unknown` or `any`)
let someValue: unknown = "I am a string";

// Using `as` syntax (recommended)
// Type Casting
let strLength: number = (someValue as string).length;

// ‚úÖ Angle-bracket syntax (not allowed in `.tsx` files)
// Equivalent to `as`, but can't be used in JSX (e.g., React projects)
let anotherValue: unknown = "Another string";
let anotherLength: number = (<string>anotherValue).length;

// ‚úÖ Summary:
// - Use type inference when possible (cleaner and safer).
// - Use type annotations when type isn‚Äôt obvious or needed for clarity.
// - Use type assertions when you're sure of a value‚Äôs type (e.g., after `unknown`).
// - Prefer `as` syntax especially in JSX/React projects.
```

---

## üîÅ Type Assertions (aka Type Casting)

TypeScript sometimes cannot infer the correct type. Type assertions let you tell the compiler "trust me, I know what I‚Äôm doing."

They do **not** change the runtime type‚Äîonly instruct the compiler.

```ts
let someValue: any = "Hello, world";
let strLength: number = (someValue as string).length;
```

or (in non-JSX files):

```ts
let strLength: number = (<string>someValue).length;
```

---

## ‚öîÔ∏è `as` vs Angle-Bracket Syntax

| Feature              | `as` Syntax                         | Angle-Bracket Syntax                 |
|----------------------|-------------------------------------|--------------------------------------|
| Syntax               | `value as Type`                     | `<Type>value`                        |
| JSX Compatibility    | ‚úÖ Works in `.tsx`                   | ‚ùå Not allowed in `.tsx` files       |
| Preferred Usage      | Always use `as` in React/JSX files | Use angle-brackets in `.ts` files    |

```ts
// ‚úÖ Preferred in all contexts
let input = someValue as string;

// ‚ùå Will cause error in TSX files
let input = <string>someValue;
```

---

## üß™ Examples

### DOM Casting

```ts
const el = document.querySelector("#my-input") as HTMLInputElement;
el.value = "Updated";
```

### Using `unknown` with assertions

```ts
function handle(data: unknown) {
  const parsed = data as string; // Asserting unknown as string
}
```

---

## ‚ö†Ô∏è Double Assertion (use carefully)

```ts
const crazy = ("text" as unknown) as number; // ‚ö†Ô∏è Avoid unless absolutely necessary
```

This should only be used in edge cases, like dealing with very dynamic third-party data.

---

## ‚úÖ Best Practices

- Prefer **inference** when the type is clear.
- Use **annotations** when inference fails or for clarity.
- Use **`as` syntax** consistently, especially in React projects.
- Avoid unnecessary or unsafe assertions ‚Äî trust the type system.
- Never use type assertions to suppress real type errors unless you are 100% confident.

```ts
// ‚ùå BAD
const user = getUser() as any;
user.nonExistentMethod();

// ‚úÖ BETTER
const user = getUser() as { name: string; age: number };
```

---
